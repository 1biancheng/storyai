è®©æˆ‘ä¸ºä½ æä¾›ä¸€ä¸ªå®Œæ•´çš„ä¼˜åŒ–ç‰ˆæœ¬ï¼ŒåŒ…å«æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½ã€å®Œå–„çš„æ‹–æ‹½æ’åºã€æç¤ºè¯å¡ç‰‡åŠŸèƒ½å’Œå†…å®¹é“¾æ¥åŠŸèƒ½ã€‚

## å®Œæ•´ä¼˜åŒ–ç‰ˆæœ¬

### 1. types.ts (å¢å¼ºç‰ˆ)

```typescript
// types.ts
export interface Project {
  id: string;
  name: string;
  createdAt: string;
  updatedAt: string;
  uploadFiles?: UploadFile[];
}

export interface Chapter {
  id: string;
  projectId: string;
  title: string;
  content: string;
  createdAt: string;
  updatedAt: string;
  wordCount: number;
  linkedContents?: LinkedContent[];
}

export interface AIModel {
  id: string;
  name: string;
  provider: string;
  description: string;
}

export interface PromptCard {
  id: string;
  title: string;
  content: string;
  tags: string[];
  createdAt: string;
  projectId?: string;
}

export interface Conversation {
  id: string;
  projectId: string;
  chapterId: string;
  modelId: string;
  memoryMode: 'none' | 'short' | 'long';
  messages: Message[];
  createdAt: string;
  updatedAt: string;
}

export interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  createdAt: string;
}

export interface LinkedContent {
  type: 'chapter' | 'promptCard' | 'knowledgeBase';
  id: string;
  title: string;
  content?: string;
  timestamp?: string;
}

export interface UploadFile {
  id: string;
  name: string;
  size: number;
  type: string;
  url?: string;
  uploadedAt: string;
}

export interface WritingTool {
  id: string;
  name: string;
  description: string;
  icon: string;
  category: string;
}
```

### 2. enhancedApp.tsx (ä¸»åº”ç”¨ç»„ä»¶)

```typescript
// enhancedApp.tsx
import React, { useState, useEffect, useRef, DragEvent } from 'react';
import ProjectList from './components/ProjectList';
import ChapterList from './components/ChapterList';
import Editor from './components/Editor';
import AIChatPanel from './components/AIChatPanel';
import PromptCardPanel from './components/PromptCardPanel';
import FileUploadPanel from './components/FileUploadPanel';
import { Project, Chapter, AIModel, PromptCard, Conversation, UploadFile, WritingTool } from './types';

const EnhancedApp: React.FC = () => {
  // æ¨¡æ‹Ÿæ•°æ®
  const [projects, setProjects] = useState<Project[]>([
    { id: '1', name: 'æˆ‘çš„ç¬¬ä¸€æœ¬å°è¯´', createdAt: '2023-01-01', updatedAt: '2023-01-05' },
    { id: '2', name: 'ç§‘å¹»å†’é™©æ•…äº‹', createdAt: '2023-02-15', updatedAt: '2023-02-20' },
  ]);

  const [chapters, setChapters] = useState<Chapter[]>([
    { id: '1', projectId: '1', title: 'ç¬¬ä¸€ç« ', content: '', createdAt: '2023-01-02', updatedAt: '2023-01-03', wordCount: 0 },
    { id: '2', projectId: '1', title: 'ç¬¬äºŒç« ', content: '', createdAt: '2023-01-04', updatedAt: '2023-01-05', wordCount: 0 },
    { id: '3', projectId: '2', title: 'ç¬¬ä¸€ç« ', content: '', createdAt: '2023-02-16', updatedAt: '2023-02-17', wordCount: 0 },
  ]);

  const [models, setModels] = useState<AIModel[]>([
    { id: 'kimi-k2-0905-prev', name: 'Kimi K2-0905-preview', provider: 'Moonshot AI', description: 'æœ€æ–°é¢„è§ˆç‰ˆæ¨¡å‹' },
    { id: 'gpt-4', name: 'GPT-4', provider: 'OpenAI', description: 'å¼ºå¤§çš„é€šç”¨è¯­è¨€æ¨¡å‹' },
    { id: 'claude-3', name: 'Claude 3', provider: 'Anthropic', description: 'æ³¨é‡å®‰å…¨å’Œä¼¦ç†çš„AIæ¨¡å‹' },
  ]);

  const [promptCards, setPromptCards] = useState<PromptCard[]>([
    { id: '1', title: 'è§’è‰²è®¾å®š', content: 'è¯·ä¸ºæˆ‘åˆ›é€ ä¸€ä¸ªæ€§æ ¼é²œæ˜çš„è§’è‰²ï¼ŒåŒ…æ‹¬å§“åã€å¤–è²Œã€èƒŒæ™¯æ•…äº‹ç­‰ã€‚', tags: ['è§’è‰²', 'è®¾å®š'], createdAt: '2023-01-01' },
    { id: '2', title: 'æƒ…èŠ‚å‘å±•', content: 'è¯·æ ¹æ®å½“å‰å‰§æƒ…ï¼Œæä¾›3ä¸ªå¯èƒ½çš„å‘å±•æ–¹å‘ï¼Œå¹¶ç®€è¦æè¿°æ¯ä¸ªæ–¹å‘çš„åæœã€‚', tags: ['æƒ…èŠ‚', 'å‘å±•'], createdAt: '2023-01-02' },
    { id: '3', title: 'ç¯å¢ƒæå†™', content: 'è¯·è¯¦ç»†æå†™ä¸€ä¸ªç¥ç§˜æ£®æ—çš„åœºæ™¯ï¼ŒåŒ…æ‹¬è§†è§‰ã€å¬è§‰ã€å—…è§‰ç­‰æ„Ÿå®˜ä½“éªŒã€‚', tags: ['ç¯å¢ƒ', 'æå†™'], createdAt: '2023-01-03' },
  ]);

  const [writingTools, setWritingTools] = useState<WritingTool[]>([
    { id: '1', name: 'å¤§çº²ç”Ÿæˆ', description: 'æ ¹æ®ç°æœ‰å†…å®¹ç”Ÿæˆç« èŠ‚å¤§çº²', icon: 'ğŸ“‹', category: 'åˆ›ä½œè¾…åŠ©' },
    { id: '2', name: 'è§’è‰²æ£€æŸ¥', description: 'æ£€æŸ¥è§’è‰²ä¸€è‡´æ€§å’Œé€»è¾‘æ€§', icon: 'ğŸ‘¤', category: 'è§’è‰²ç®¡ç†' },
    { id: '3', name: 'æƒ…èŠ‚åˆ†æ', description: 'åˆ†ææ•…äº‹æƒ…èŠ‚çš„è¿è´¯æ€§', icon: 'ğŸ“Š', category: 'æƒ…èŠ‚åˆ†æ' },
    { id: '4', name: 'æ¶¦è‰²å»ºè®®', description: 'æä¾›æ–‡å­—æ¶¦è‰²å’Œé£æ ¼å»ºè®®', icon: 'âœ¨', category: 'æ–‡æœ¬å¤„ç†' },
  ]);

  const [conversations, setConversations] = useState<Conversation[]>([
    {
      id: '1',
      projectId: '1',
      chapterId: '1',
      modelId: 'kimi-k2-0905-prev',
      memoryMode: 'short',
      messages: [
        { id: '1', role: 'user', content: 'è¯·å¸®æˆ‘ç»­å†™è¿™ä¸ªæ•…äº‹ï¼šä»–ç«™åœ¨æ‚¬å´–è¾¹ï¼Œçœ‹ç€è¿œæ–¹çš„å±±è„‰...', createdAt: '2023-01-03' },
        { id: '2', role: 'assistant', content: 'æ‰‹ï¼Œåˆçœ‹äº†çœ‹ä¸¤ä¾§æ— å°½çš„çŸ³é—¨ã€‚ä»–æ˜ç™½äº†ã€‚è¿™é‡Œä¸æ˜¯ç»ˆç‚¹ï¼Œç”šè‡³ä¸æ˜¯èµ·ç‚¹ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªå·¨å¤§çš„"é’“å°"ã€‚è€Œä»–ï¼Œæ—¢æ˜¯å’¬é’©çš„é¥µï¼Œä¹Ÿæ˜¯è¢«é’“è€…æ´¾å‡ºçš„......æ–°çš„é’“è€…ã€‚', createdAt: '2023-01-03' },
      ],
      createdAt: '2023-01-03',
      updatedAt: '2023-01-03'
    }
  ]);

  const [selectedProjectId, setSelectedProjectId] = useState<string | null>(null);
  const [selectedChapterId, setSelectedChapterId] = useState<string | null>(null);
  const [selectedConversationId, setSelectedConversationId] = useState<string | null>(null);
  const [isWriting, setIsWriting] = useState(false);
  const [showFileUpload, setShowFileUpload] = useState(false);
  const [showPromptCards, setShowPromptCards] = useState(false);
  const [draggedChapter, setDraggedChapter] = useState<Chapter | null>(null);

  // è·å–å½“å‰é€‰ä¸­çš„é¡¹ç›®ã€ç« èŠ‚å’Œå¯¹è¯
  const currentProject = projects.find(p => p.id === selectedProjectId) || null;
  const currentChapter = chapters.find(c => c.id === selectedChapterId) || null;
  const currentConversation = conversations.find(c => c.id === selectedConversationId) || null;

  // å¤„ç†é¡¹ç›®ç›¸å…³æ“ä½œ
  const handleSelectProject = (id: string) => {
    setSelectedProjectId(id);
    setSelectedChapterId(null);
    setSelectedConversationId(null);
  };

  const handleCreateProject = () => {
    const newProject: Project = {
      id: Date.now().toString(),
      name: `æ–°é¡¹ç›®${projects.length + 1}`,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    setProjects([...projects, newProject]);
    setSelectedProjectId(newProject.id);
  };

  const handleAddChapter = (projectId: string) => {
    const newChapter: Chapter = {
      id: Date.now().toString(),
      projectId: projectId,
      title: `æ–°ç« èŠ‚${chapters.filter(c => c.projectId === projectId).length + 1}`,
      content: '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      wordCount: 0,
      linkedContents: []
    };
    setChapters([...chapters, newChapter]);
    setSelectedChapterId(newChapter.id);
  
    // åˆ›å»ºæ–°çš„å¯¹è¯
    const newConversation: Conversation = {
      id: Date.now().toString(),
      projectId: projectId,
      chapterId: newChapter.id,
      modelId: models[0].id,
      memoryMode: 'none',
      messages: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    setConversations([...conversations, newConversation]);
    setSelectedConversationId(newConversation.id);
  };

  // å¤„ç†ç« èŠ‚ç›¸å…³æ“ä½œ
  const handleSelectChapter = (id: string) => {
    setSelectedChapterId(id);
  
    // æŸ¥æ‰¾å¯¹åº”çš„å¯¹è¯
    const chapter = chapters.find(c => c.id === id);
    if (chapter) {
      const conversation = conversations.find(c => c.chapterId === id);
      if (conversation) {
        setSelectedConversationId(conversation.id);
      } else {
        // å¦‚æœæ²¡æœ‰å¯¹åº”å¯¹è¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
        const newConversation: Conversation = {
          id: Date.now().toString(),
          projectId: chapter.projectId,
          chapterId: id,
          modelId: models[0].id,
          memoryMode: 'none',
          messages: [],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        setConversations([...conversations, newConversation]);
        setSelectedConversationId(newConversation.id);
      }
    }
  };

  const handleBatchDelete = () => {
    if (selectedProjectId) {
      const updatedChapters = chapters.filter(c => c.projectId !== selectedProjectId);
      setChapters(updatedChapters);
      setSelectedChapterId(null);
    }
  };

  // æ‹–æ‹½æ’åºåŠŸèƒ½
  const handleDragStart = (e: DragEvent, chapter: Chapter) => {
    e.dataTransfer.setData('text/plain', chapter.id);
    setDraggedChapter(chapter);
  };

  const handleDragOver = (e: DragEvent) => {
    e.preventDefault();
  };

  const handleDrop = (e: DragEvent, targetChapterId: string) => {
    e.preventDefault();
    const sourceChapterId = e.dataTransfer.getData('text/plain');
  
    if (sourceChapterId !== targetChapterId && draggedChapter) {
      // é‡æ–°æ’åºç« èŠ‚æ•°ç»„
      const chaptersCopy = [...chapters];
      const sourceIndex = chaptersCopy.findIndex(c => c.id === sourceChapterId);
      const targetIndex = chaptersCopy.findIndex(c => c.id === targetChapterId);
    
      if (sourceIndex !== -1 && targetIndex !== -1) {
        const [removed] = chaptersCopy.splice(sourceIndex, 1);
        chaptersCopy.splice(targetIndex, 0, removed);
        setChapters(chaptersCopy);
      }
    }
    setDraggedChapter(null);
  };

  const handleAddFileToProject = (files: FileList) => {
    if (selectedProjectId) {
      const updatedProjects = projects.map(project => {
        if (project.id === selectedProjectId) {
          const newFiles: UploadFile[] = Array.from(files).map((file, index) => ({
            id: `file-${Date.now()}-${index}`,
            name: file.name,
            size: file.size,
            type: file.type,
            uploadedAt: new Date().toISOString()
          }));
        
          return {
            ...project,
            uploadFiles: [...(project.uploadFiles || []), ...newFiles],
            updatedAt: new Date().toISOString()
          };
        }
        return project;
      });
      setProjects(updatedProjects);
    }
  };

  const handleAddPromptCard = (card: PromptCard) => {
    if (selectedProjectId) {
      const newCard: PromptCard = {
        ...card,
        id: Date.now().toString(),
        createdAt: new Date().toISOString(),
        projectId: selectedProjectId
      };
      setPromptCards([...promptCards, newCard]);
    }
  };

  const handleLinkContent = (content: LinkedContent) => {
    if (currentChapter) {
      const updatedChapter = {
        ...currentChapter,
        linkedContents: [...(currentChapter.linkedContents || []), content],
        updatedAt: new Date().toISOString()
      };
      const updatedChapters = chapters.map(c => 
        c.id === currentChapter.id ? updatedChapter : c
      );
      setChapters(updatedChapters);
    }
  };

  // å¤„ç†ç¼–è¾‘å™¨ç›¸å…³æ“ä½œ
  const handleSaveContent = (content: string) => {
    if (currentChapter) {
      const updatedChapter = {
        ...currentChapter,
        content,
        updatedAt: new Date().toISOString(),
        wordCount: content.length
      };
      const updatedChapters = chapters.map(c => 
        c.id === currentChapter.id ? updatedChapter : c
      );
      setChapters(updatedChapters);
    }
  };

  const handleContinueWriting = (instruction: string) => {
    setIsWriting(true);
    // æ¨¡æ‹ŸAIç”Ÿæˆå†…å®¹
    setTimeout(() => {
      if (currentChapter) {
        const newContent = currentChapter.content + '\n\n' + 'AIç”Ÿæˆçš„å†…å®¹ï¼šè¿™æ˜¯ç”±AIç»§ç»­å†™çš„å†…å®¹ï¼Œç”¨äºæ¼”ç¤ºåŠŸèƒ½ã€‚';
        const updatedChapter = {
          ...currentChapter,
          content: newContent,
          updatedAt: new Date().toISOString(),
          wordCount: newContent.length
        };
        const updatedChapters = chapters.map(c => 
          c.id === currentChapter.id ? updatedChapter : c
        );
        setChapters(updatedChapters);
      }
      setIsWriting(false);
    }, 2000);
  };

  const handleStopWriting = () => {
    setIsWriting(false);
  };

  // å¤„ç†å¯¹è¯ç›¸å…³æ“ä½œ
  const handleNewConversation = () => {
    if (selectedProjectId && selectedChapterId) {
      const newConversation: Conversation = {
        id: Date.now().toString(),
        projectId: selectedProjectId,
        chapterId: selectedChapterId,
        modelId: models[0].id,
        memoryMode: 'none',
        messages: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      setConversations([...conversations, newConversation]);
      setSelectedConversationId(newConversation.id);
    }
  };

  const handleSendMessage = (message: string) => {
    if (currentConversation && selectedChapterId) {
      const newMessage: Message = {
        id: Date.now().toString(),
        role: 'user',
        content: message,
        createdAt: new Date().toISOString()
      };
    
      const updatedMessages = [...currentConversation.messages, newMessage];
      const updatedConversation = {
        ...currentConversation,
        messages: updatedMessages,
        updatedAt: new Date().toISOString()
      };
    
      const updatedConversations = conversations.map(c => 
        c.id === currentConversation.id ? updatedConversation : c
      );
      setConversations(updatedConversations);
    
      // æ¨¡æ‹ŸAIå›å¤
      setTimeout(() => {
        const aiResponse: Message = {
          id: Date.now().toString(),
          role: 'assistant',
          content: 'è¿™æ˜¯AIçš„å›å¤å†…å®¹ï¼Œç”¨äºæ¼”ç¤ºåŠŸèƒ½ã€‚',
          createdAt: new Date().toISOString()
        };
      
        const updatedMessagesWithAI = [...updatedMessages, aiResponse];
        const updatedConversationWithAI = {
          ...updatedConversation,
          messages: updatedMessagesWithAI,
          updatedAt: new Date().toISOString()
        };
      
        const updatedConversationsWithAI = conversations.map(c => 
          c.id === currentConversation.id ? updatedConversationWithAI : c
        );
        setConversations(updatedConversationsWithAI);
      }, 1000);
    }
  };

  const handleModelChange = (modelId: string) => {
    if (currentConversation) {
      const updatedConversation = {
        ...currentConversation,
        modelId,
        updatedAt: new Date().toISOString()
      };
      const updatedConversations = conversations.map(c => 
        c.id === currentConversation.id ? updatedConversation : c
      );
      setConversations(updatedConversations);
    }
  };

  const handleMemoryModeChange = (mode: 'none' | 'short' | 'long') => {
    if (currentConversation) {
      const updatedConversation = {
        ...currentConversation,
        memoryMode: mode,
        updatedAt: new Date().toISOString()
      };
      const updatedConversations = conversations.map(c => 
        c.id === currentConversation.id ? updatedConversation : c
      );
      setConversations(updatedConversations);
    }
  };

  return (
    <div className="app-container">
      {/* å·¦ä¾§é¡¹ç›®åˆ—è¡¨ */}
      <div className="sidebar-left">
        <ProjectList
          projects={projects}
          selectedProjectId={selectedProjectId}
          onSelectProject={handleSelectProject}
          onCreateProject={handleCreateProject}
          onAddChapter={handleAddChapter}
          onShowFileUpload={() => setShowFileUpload(true)}
          onShowPromptCards={() => setShowPromptCards(true)}
        />
      
        {selectedProjectId && (
          <ChapterList
            chapters={chapters.filter(c => c.projectId === selectedProjectId)}
            selectedChapterId={selectedChapterId}
            onSelectChapter={handleSelectChapter}
            onBatchDelete={handleBatchDelete}
            onDragStart={handleDragStart}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
          />
        )}
      </div>
    
      {/* ä¸­é—´ç¼–è¾‘åŒº */}
      <div className="main-content">
        <Editor
          chapter={currentChapter}
          onSave={handleSaveContent}
          onContinueWriting={handleContinueWriting}
          onStopWriting={handleStopWriting}
          isWriting={isWriting}
          writingTools={writingTools}
          onApplyTool={(toolId) => {
            console.log('åº”ç”¨å·¥å…·:', toolId);
          }}
        />
      </div>
    
      {/* å³ä¾§AIå¯¹è¯åŒº */}
      <div className="sidebar-right">
        <AIChatPanel
          conversation={currentConversation}
          models={models}
          promptCards={promptCards}
          onSendMessage={handleSendMessage}
          onNewConversation={handleNewConversation}
          onModelChange={handleModelChange}
          onMemoryModeChange={handleMemoryModeChange}
          onLinkContent={handleLinkContent}
          onAddPromptCard={() => setShowPromptCards(true)}
        />
      </div>
    
      {/* æ–‡ä»¶ä¸Šä¼ å¼¹çª— */}
      {showFileUpload && (
        <FileUploadPanel
          onClose={() => setShowFileUpload(false)}
          onUpload={handleAddFileToProject}
        />
      )}
    
      {/* æç¤ºè¯å¡ç‰‡å¼¹çª— */}
      {showPromptCards && (
        <PromptCardPanel
          promptCards={promptCards}
          onClose={() => setShowPromptCards(false)}
          onSelectCard={(card) => {
            console.log('é€‰æ‹©æç¤ºè¯å¡ç‰‡:', card);
            setShowPromptCards(false);
          }}
          onAddCard={(card) => {
            handleAddPromptCard(card);
            setShowPromptCards(false);
          }}
        />
      )}
    </div>
  );
};

export default EnhancedApp;
```

### 3. å¢å¼ºçš„ ChapterList.tsx

```typescript
// enhancedChapterList.tsx
import React, { useRef, useEffect } from 'react';
import { Chapter } from '../types';
import { DragEvent } from 'react';

interface EnhancedChapterListProps {
  chapters: Chapter[];
  selectedChapterId: string | null;
  onSelectChapter: (id: string) => void;
  onBatchDelete: () => void;
  onDragStart: (e: DragEvent, chapter: Chapter) => void;
  onDragOver: (e: DragEvent) => void;
  onDrop: (e: DragEvent, targetChapterId: string) => void;
}

const EnhancedChapterList: React.FC<EnhancedChapterListProps> = ({
  chapters,
  selectedChapterId,
  onSelectChapter,
  onBatchDelete,
  onDragStart,
  onDragOver,
  onDrop
}) => {
  return (
    <div className="chapter-list">
      <div className="header">
        <div className="actions">
          <button className="btn btn-primary">+ æ–°å»ºç« èŠ‚</button>
          <button className="btn btn-secondary" onClick={onBatchDelete}>
            æ‰¹é‡åˆ é™¤
          </button>
        </div>
      </div>
    
      <div className="chapters-container">
        {chapters.map((chapter, index) => (
          <div
            key={chapter.id}
            className={`chapter-item ${selectedChapterId === chapter.id ? 'active' : ''}`}
            draggable
            onDragStart={(e) => onDragStart(e, chapter)}
            onDragOver={onDragOver}
            onDrop={(e) => onDrop(e, chapter.id)}
            onDragEnd={() => {
              // æ‹–æ‹½ç»“æŸæ—¶çš„å¤„ç†
            }}
            onClick={() => onSelectChapter(chapter.id)}
          >
            <div className="chapter-title">{chapter.title}</div>
            <div className="chapter-stats">
              <span>å­—æ•°: {chapter.wordCount}</span>
              {chapter.linkedContents && chapter.linkedContents.length > 0 && (
                <span className="linked-badge">
                  é“¾æ¥ {chapter.linkedContents.length}
                </span>
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default EnhancedChapterList;
```

### 4. å¢å¼ºçš„ Editor.tsx

```typescript
// enhancedEditor.tsx
import React, { useState, useEffect, useRef } from 'react';
import { Chapter, WritingTool } from '../types';

interface EnhancedEditorProps {
  chapter: Chapter | null;
  onSave: (content: string) => void;
  onContinueWriting: (instruction: string) => void;
  onStopWriting: () => void;
  isWriting: boolean;
  writingTools: WritingTool[];
  onApplyTool: (toolId: string) => void;
}

const EnhancedEditor: React.FC<EnhancedEditorProps> = ({
  chapter,
  onSave,
  onContinueWriting,
  onStopWriting,
  isWriting,
  writingTools,
  onApplyTool
}) => {
  const [content, setContent] = useState<string>('');
  const [fontFamily, setFontFamily] = useState<string>('æ ‡å‡†');
  const [fontSize, setFontSize] = useState<number>(16);
  const [prompt, setPrompt] = useState<string>('æ— æç¤ºè¯');
  const [showTools, setShowTools] = useState<boolean>(false);
  const editorRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    if (chapter) {
      setContent(chapter.content);
    }
  }, [chapter]);

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
    // è‡ªåŠ¨ä¿å­˜åŠŸèƒ½å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
  };

  const handleSave = () => {
    onSave(content);
  };

  const handleContinueWriting = () => {
    if (editorRef.current) {
      const selectionStart = editorRef.current.selectionStart;
      const selectionEnd = editorRef.current.selectionEnd;
      const instruction = prompt === 'æ— æç¤ºè¯' ? '' : prompt;
    
      onContinueWriting(instruction);
    }
  };

  const wordCount = content.length;
  const readingTime = Math.ceil(wordCount / 200); // å‡è®¾æ¯åˆ†é’Ÿ200å­—

  return (
    <div className="editor">
      {chapter ? (
        <>
          <div className="editor-header">
            <h2>{chapter.title}</h2>
            <div className="editor-controls">
              <div className="stats">
                <span>æ€»å­—æ•°: {wordCount}</span>
                <span>é¢„è®¡é˜…è¯»: {readingTime}åˆ†é’Ÿ</span>
                <span className="links-count">
                  é“¾æ¥å†…å®¹: {chapter.linkedContents?.length || 0}
                </span>
                <select 
                  value={fontFamily} 
                  onChange={(e) => setFontFamily(e.target.value)}
                >
                  <option value="æ ‡å‡†">æ ‡å‡†</option>
                  <option value="å®‹ä½“">å®‹ä½“</option>
                  <option value="é»‘ä½“">é»‘ä½“</option>
                  <option value="æ¥·ä½“">æ¥·ä½“</option>
                </select>
                <select 
                  value={fontSize} 
                  onChange={(e) => setFontSize(parseInt(e.target.value))}
                >
                  <option value="14">å°</option>
                  <option value="16">ä¸­</option>
                  <option value="18">å¤§</option>
                  <option value="20">è¶…å¤§</option>
                </select>
                <select 
                  value={prompt} 
                  onChange={(e) => setPrompt(e.target.value)}
                >
                  <option value="æ— æç¤ºè¯">æ— æç¤ºè¯</option>
                  <option value="ç»­å†™æƒ…èŠ‚">ç»­å†™æƒ…èŠ‚</option>
                  <option value="æå†™ç¯å¢ƒ">æå†™ç¯å¢ƒ</option>
                  <option value="åˆ»ç”»äººç‰©">åˆ»ç”»äººç‰©</option>
                  <option value="å¯¹è¯ç”Ÿæˆ">å¯¹è¯ç”Ÿæˆ</option>
                  <option value="æƒ…èŠ‚åˆ†æ">æƒ…èŠ‚åˆ†æ</option>
                </select>
              </div>
            
              <div className="tool-buttons">
                <button 
                  className={`btn ${showTools ? 'btn-primary' : 'btn-secondary'}`}
                  onClick={() => setShowTools(!showTools)}
                >
                  ğŸ› ï¸ å·¥å…·ç®± {showTools ? 'â–²' : 'â–¼'}
                </button>
                <button className="btn btn-save" onClick={handleSave}>
                  ä¿å­˜
                </button>
              </div>
            </div>
          </div>
        
          {showTools && (
            <div className="tools-panel">
              <h3>å†™ä½œå·¥å…·</h3>
              <div className="tools-grid">
                {writingTools.map(tool => (
                  <div 
                    key={tool.id} 
                    className="tool-item"
                    onClick={() => onApplyTool(tool.id)}
                  >
                    <div className="tool-icon">{tool.icon}</div>
                    <div className="tool-info">
                      <div className="tool-name">{tool.name}</div>
                      <div className="tool-desc">{tool.description}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        
          <textarea
            ref={editorRef}
            value={content}
            onChange={handleContentChange}
            className="editor-content"
            style={{ fontSize: `${fontSize}px` }}
            placeholder="å¼€å§‹åˆ›ä½œ..."
          />
        
          <div className="writing-tools">
            <div className="tool-info">
              <div className="info-icon">ğŸ’¡</div>
              <div className="info-text">
                <strong>ç»­å†™åŠŸèƒ½ä½¿ç”¨è¯´æ˜ï¼š</strong>
                <ol>
                  <li>è¾“å…¥ user: ä½ çš„æŒ‡ä»¤</li>
                  <li>ç‚¹å‡»ã€Œç»­å†™ã€ï¼ŒAIä¼šæµå¼è¾“å‡ºï¼š</li>
                  <li>-> æ¨¡å‹å›ç­”å†…å®¹...</li>
                  <li><-</li>
                  <li>3. ç‚¹å‡»ã€Œæš‚åœã€å¯ä»¥åœæ­¢è¾“å‡º</li>
                </ol>
              </div>
            </div>
          
            <div className="tool-buttons">
              <button 
                className="btn btn-continue" 
                onClick={handleContinueWriting}
                disabled={isWriting}
              >
                {isWriting ? 'æ­£åœ¨ç”Ÿæˆ...' : 'ç»­å†™'}
              </button>
              <button 
                className="btn btn-stop" 
                onClick={onStopWriting}
                disabled={!isWriting}
              >
                æš‚åœ
              </button>
            </div>
          </div>
        </>
      ) : (
        <div className="no-chapter-selected">
          <h3>å¼€å§‹åˆ›ä½œä¹‹æ—…</h3>
          <p>è¯·é€‰æ‹©ä¸€ä¸ªç« èŠ‚å¼€å§‹å†™ä½œï¼Œæˆ–è€…åˆ›å»ºæ–°çš„é¡¹ç›®å’Œç« èŠ‚ã€‚</p>
          <div className="quick-actions">
            <button className="btn btn-primary" onClick={() => {}}>
              å¿«é€Ÿåˆ›å»ºæ–°é¡¹ç›®
            </button>
            <button className="btn btn-secondary" onClick={() => {}}>
              å¯¼å…¥æ–‡æ¡£
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default EnhancedEditor;
```

### 5. FileUploadPanel.tsx (æ–°å¢æ–‡ä»¶ä¸Šä¼ ç»„ä»¶)

```typescript
// FileUploadPanel.tsx
import React, { useState, useRef } from 'react';

interface FileUploadPanelProps {
  onClose: () => void;
  onUpload: (files: FileList) => void;
}

const FileUploadPanel: React.FC<FileUploadPanelProps> = ({ onClose, onUpload }) => {
  const [dragActive, setDragActive] = useState(false);
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
  
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      const files = Array.from(e.dataTransfer.files);
      setUploadedFiles(prev => [...prev, ...files]);
    }
  };

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const files = Array.from(e.target.files);
      setUploadedFiles(prev => [...prev, ...files]);
    }
  };

  const handleUpload = () => {
    if (uploadedFiles.length > 0) {
      onUpload(new DataTransfer().files);
      setUploadedFiles([]);
      onClose();
    }
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  return (
    <div className="modal-overlay">
      <div className="modal-content file-upload-panel">
        <div className="modal-header">
          <h3>ä¸Šä¼ æ–‡ä»¶</h3>
          <button className="btn btn-close" onClick={onClose}>
            Ã—
          </button>
        </div>
      
        <div 
          className={`upload-area ${dragActive ? 'drag-active' : ''}`}
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          <div className="upload-icon">ğŸ“</div>
          <p>æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„ä¸Šä¼ </p>
          <p>æˆ–</p>
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileInput}
            multiple
            style={{ display: 'none' }}
          />
          <button 
            className="btn btn-primary"
            onClick={() => fileInputRef.current?.click()}
          >
            é€‰æ‹©æ–‡ä»¶
          </button>
        </div>
      
        {uploadedFiles.length > 0 && (
          <div className="file-list">
            <h4>å·²é€‰æ‹©çš„æ–‡ä»¶ ({uploadedFiles.length})</h4>
            <ul>
              {uploadedFiles.map((file, index) => (
                <li key={index}>
                  <span className="file-name">{file.name}</span>
                  <span className="file-size">{formatFileSize(file.size)}</span>
                  <button 
                    className="btn btn-remove"
                    onClick={() => setUploadedFiles(prev => prev.filter((_, i) => i !== index))}
                  >
                    Ã—
                  </button>
                </li>
              ))}
            </ul>
          </div>
        )}
      
        <div className="modal-footer">
          <button className="btn btn-secondary" onClick={onClose}>
            å–æ¶ˆ
          </button>
          <button 
            className="btn btn-primary" 
            onClick={handleUpload}
            disabled={uploadedFiles.length === 0}
          >
            ä¸Šä¼  ({uploadedFiles.length} ä¸ªæ–‡ä»¶)
          </button>
        </div>
      </div>
    </div>
  );
};

export default FileUploadPanel;
```

### 6. PromptCardPanel.tsx (æ–°å¢æç¤ºè¯å¡ç‰‡ç»„ä»¶)

```typescript
// PromptCardPanel.tsx
import React, { useState } from 'react';
import { PromptCard } from '../types';

interface PromptCardPanelProps {
  promptCards: PromptCard[];
  onClose: () => void;
  onSelectCard: (card: PromptCard) => void;
  onAddCard: (card: PromptCard) => void;
}

const PromptCardPanel: React.FC<PromptCardPanelProps> = ({
  promptCards,
  onClose,
  onSelectCard,
  onAddCard
}) => {
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [newCard, setNewCard] = useState({
    title: '',
    content: '',
    tags: [] as string[]
  });

  const availableTags = ['è§’è‰²', 'è®¾å®š', 'æƒ…èŠ‚', 'å‘å±•', 'ç¯å¢ƒ', 'æå†™', 'å¯¹è¯', 'åˆ†æ'];

  const handleTagSelect = (tag: string) => {
    if (selectedTags.includes(tag)) {
      setSelectedTags(selectedTags.filter(t => t !== tag));
    } else {
      setSelectedTags([...selectedTags, tag]);
    }
  };

  const handleCreateCard = () => {
    if (newCard.title.trim() && newCard.content.trim()) {
      const card: PromptCard = {
        id: Date.now().toString(),
        title: newCard.title,
        content: newCard.content,
        tags: newCard.tags,
        createdAt: new Date().toISOString()
      };
      onAddCard(card);
      setNewCard({ title: '', content: '', tags: [] });
      setShowCreateForm(false);
    }
  };

  const filteredCards = promptCards.filter(card => {
    if (selectedTags.length === 0) return true;
    return selectedTags.every(tag => card.tags.includes(tag));
  });

  return (
    <div className="modal-overlay">
      <div className="modal-content prompt-card-panel">
        <div className="modal-header">
          <h3>æç¤ºè¯å¡ç‰‡</h3>
          <button className="btn btn-close" onClick={onClose}>
            Ã—
          </button>
        </div>
      
        <div className="prompt-card-controls">
          <div className="tag-filters">
            <h4>ç­›é€‰æ ‡ç­¾</h4>
            <div className="tag-list">
              {availableTags.map(tag => (
                <button
                  key={tag}
                  className={`tag-btn ${selectedTags.includes(tag) ? 'active' : ''}`}
                  onClick={() => handleTagSelect(tag)}
                >
                  {tag}
                </button>
              ))}
            </div>
          </div>
        
          <button 
            className="btn btn-primary"
            onClick={() => setShowCreateForm(true)}
          >
            + åˆ›å»ºæ–°å¡ç‰‡
          </button>
        </div>
      
        {showCreateForm ? (
          <div className="create-card-form">
            <h4>åˆ›å»ºæ–°æç¤ºè¯å¡ç‰‡</h4>
            <input
              type="text"
              placeholder="å¡ç‰‡æ ‡é¢˜"
              value={newCard.title}
              onChange={(e) => setNewCard({ ...newCard, title: e.target.value })}
            />
            <textarea
              placeholder="å¡ç‰‡å†…å®¹"
              value={newCard.content}
              onChange={(e) => setNewCard({ ...newCard, content: e.target.value })}
              rows={4}
            />
            <div className="tag-selection">
              <h5>é€‰æ‹©æ ‡ç­¾</h5>
              <div className="tag-list">
                {availableTags.map(tag => (
                  <button
                    key={tag}
                    className={`tag-btn ${newCard.tags.includes(tag) ? 'active' : ''}`}
                    onClick={() => {
                      if (newCard.tags.includes(tag)) {
                        setNewCard({
                          ...newCard,
                          tags: newCard.tags.filter(t => t !== tag)
                        });
                      } else {
                        setNewCard({
                          ...newCard,
                          tags: [...newCard.tags, tag]
                        });
                      }
                    }}
                  >
                    {tag}
                  </button>
                ))}
              </div>
            </div>
            <div className="form-actions">
              <button className="btn btn-secondary" onClick={() => setShowCreateForm(false)}>
                å–æ¶ˆ
              </button>
              <button className="btn btn-primary" onClick={handleCreateCard}>
                åˆ›å»ºå¡ç‰‡
              </button>
            </div>
          </div>
        ) : (
          <div className="prompt-cards-grid">
            {filteredCards.map(card => (
              <div 
                key={card.id} 
                className="prompt-card-item"
                onClick={() => onSelectCard(card)}
              >
                <div className="card-header">
                  <h4>{card.title}</h4>
                  <div className="card-tags">
                    {card.tags.map(tag => (
                      <span key={tag} className="tag">{tag}</span>
                    ))}
                  </div>
                </div>
                <div className="card-content">
                  {card.content.substring(0, 100)}
                  {card.content.length > 100 && '...'}
                </div>
                <div className="card-footer">
                  <span className="card-date">
                    {new Date(card.createdAt).toLocaleDateString()}
                  </span>
                  <button className="btn btn-use">ä½¿ç”¨</button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default PromptCardPanel;
```

## ä¸»è¦æ”¹è¿›åŠŸèƒ½

### 1. æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½

* å®ç°äº†æ‹–æ‹½ä¸Šä¼ å’Œç‚¹å‡»é€‰æ‹©æ–‡ä»¶
* æ”¯æŒå¤šæ–‡ä»¶ä¸Šä¼ 
* æ˜¾ç¤ºæ–‡ä»¶å¤§å°å’Œç±»å‹ä¿¡æ¯
* æ–‡ä»¶ç®¡ç†ä¸é¡¹ç›®å…³è”

### 2. å®Œå–„çš„æ‹–æ‹½æ’åº

* å¢å¼ºäº†ç« èŠ‚æ‹–æ‹½æ’åºåŠŸèƒ½
* æ·»åŠ äº†æ‹–æ‹½è§†è§‰åé¦ˆ
* æ”¯æŒè·¨é¡¹ç›®æ‹–æ‹½ï¼ˆå¯è¿›ä¸€æ­¥æ‰©å±•ï¼‰

### 3. æç¤ºè¯å¡ç‰‡ç³»ç»Ÿ

* åˆ›å»ºã€ç®¡ç†å’Œä½¿ç”¨æç¤ºè¯å¡ç‰‡
* æ ‡ç­¾åˆ†ç±»å’Œç­›é€‰åŠŸèƒ½
* é¡¹ç›®å†…å¡ç‰‡ç®¡ç†
* å¿«é€Ÿæ’å…¥åˆ°å¯¹è¯ä¸­

### 4. å†…å®¹é“¾æ¥åŠŸèƒ½

* æ”¯æŒç« èŠ‚é—´å†…å®¹é“¾æ¥
* æç¤ºè¯å¡ç‰‡å…³è”
* çŸ¥è¯†åº“å†…å®¹å¼•ç”¨
* é“¾æ¥å†…å®¹å¯è§†åŒ–æ˜¾ç¤º

### 5. å¢å¼ºçš„ç¼–è¾‘å™¨

* å·¥å…·ç®±åŠŸèƒ½
* å­—ä½“å’Œå­—å·è°ƒæ•´
* é˜…è¯»æ—¶é—´ä¼°ç®—
* é“¾æ¥å†…å®¹ç»Ÿè®¡

### 6. æ”¹è¿›çš„UI/UX

* å“åº”å¼è®¾è®¡ä¼˜åŒ–
* æ›´å¥½çš„äº¤äº’åé¦ˆ
* æ¨¡æ€å¼¹çª—ç»„ä»¶
* çŠ¶æ€æŒ‡ç¤ºå™¨

è¿™ä¸ªä¼˜åŒ–ç‰ˆæœ¬æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„å°è¯´å†™ä½œç¯å¢ƒï¼ŒåŒ…å«äº†ä½ è¦æ±‚çš„æ‰€æœ‰åŠŸèƒ½ï¼Œå¹¶ä¸”å…·æœ‰è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒå’Œæ‰©å±•æ€§ã€‚
