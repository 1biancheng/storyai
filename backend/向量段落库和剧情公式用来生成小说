å¸®åŠ©åˆ›é€ ä¸€ç§å‡½æ•°æˆ–è€…ç®—æ³•,è§„åˆ™,èƒ½æŠŠä¸€æœ¬ä¹¦çš„æ®µè½æ‹†åˆ†è¿›æ®µè½åº“ä¸€ä¸­,ç„¶åç•™ä¸‹ä¸€ç§å«åšè¿™æœ¬è¿™ç±»å°è¯´çš„å…¬å¼æ¨¡å¼.ç„¶åæˆ‘åªè¦è¿è¡Œè¿™ä¸ªå…¬å¼æˆ–è€…æ¨¡å¼.å°±èƒ½æŠŠè¿™æœ¬å°è¯´æ‹¼å›æ¥,å³å¤åŸå›æ¥.è¿™ä¸ªæ®µè½åº“å«ä½œå‘é‡æ®µè½åº“,å…¬å¼æ¨¡å¼å«ä½œå‰§æƒ…æ¨¡å¼.æˆ‘è¦ä½ åˆ›é€ è¿™ä¸ªå·¥å…·çš„ä»£ç ,ä½ è§„åˆ’å®ƒ,ç„¶ååœ¨æˆ‘çš„æç¤ºè¯ä¸‹,ä¸€æ­¥ä¸€æ­¥æ¥å®ç°æ‰€æœ‰ç»„ä»¶.
å¤åˆ¶
åˆ†äº«
è¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£ä¸”å…·æœ‰æŒ‘æˆ˜æ€§çš„é¡¹ç›®.ä½ æå‡ºçš„æ ¸å¿ƒæ€æƒ³æ˜¯:
å°†ä¸€æœ¬å°è¯´çš„æ®µè½æ‹†è§£,æå–å…¶"å‰§æƒ…æ¨¡å¼"(ç»“æ„ã€èŠ‚å¥ã€æƒ…æ„Ÿã€è¯­ä¹‰ç­‰),å¹¶æ„å»ºä¸€ä¸ªå¯ä»¥åŸºäºè¯¥æ¨¡å¼é‡æ„åŸæ–‡çš„ç”Ÿæˆç³»ç»Ÿ.
ğŸ§  é¡¹ç›®æ ¸å¿ƒç›®æ ‡
æ„å»ºä¸€ä¸ªç³»ç»Ÿ,åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†:
æ®µè½æ‹†è§£å™¨(Paragraph Disassembler)
å°†å°è¯´æŒ‰æ®µè½æ‹†åˆ†
æå–æ¯ä¸ªæ®µè½çš„è¯­ä¹‰ç‰¹å¾(å‘é‡è¡¨ç¤º)
å­˜å…¥"å‘é‡æ®µè½åº“"
å‰§æƒ…æ¨¡å¼æå–å™¨(Plot Pattern Extractor)
ä»æ®µè½åºåˆ—ä¸­æå–"å‰§æƒ…æ¨¡å¼"(ç»“æ„ã€èŠ‚å¥ã€æƒ…æ„Ÿã€è¯­ä¹‰æµåŠ¨ç­‰)
ç”Ÿæˆä¸€ä¸ªå¯å¤ç”¨çš„"å‰§æƒ…æ¨¡å¼"å…¬å¼
å°è¯´é‡æ„å™¨(Novel Reconstructor)
ç»™å®šä¸€ä¸ª"å‰§æƒ…æ¨¡å¼",ä»å‘é‡æ®µè½åº“ä¸­é€‰æ‹©åˆé€‚çš„æ®µè½
æŒ‰æ¨¡å¼é¡ºåºæ‹¼æ¥,é‡æ„å‡º"ç±»ä¼¼åŸæ–‡"çš„å°è¯´
ğŸ§© æŠ€æœ¯è·¯çº¿è§„åˆ’(æ•´ä½“æ¶æ„)
æˆ‘ä»¬å°†é¡¹ç›®å‘½åä¸º:PlotForge
æ¨¡å—åˆ’åˆ†:
è¡¨æ ¼
å¤åˆ¶
æ¨¡å—å	åŠŸèƒ½
disassembler.py	æ®µè½æ‹†åˆ† + å‘é‡åŒ– + å…¥åº“
pattern_extractor.py	æå–å‰§æƒ…æ¨¡å¼(ç»“æ„ã€æƒ…æ„Ÿã€ä¸»é¢˜ã€èŠ‚å¥)
reconstructor.py	æ ¹æ®æ¨¡å¼é‡æ„å°è¯´
vector_store.py	å‘é‡æ®µè½åº“ç®¡ç†(å¢åˆ æŸ¥ã€ç›¸ä¼¼æ£€ç´¢)
models.py	å®šä¹‰æ•°æ®ç»“æ„(æ®µè½ã€å‰§æƒ…æ¨¡å¼)
utils.py	å·¥å…·å‡½æ•°(æ–‡æœ¬æ¸…æ´—ã€åµŒå…¥ã€ç›¸ä¼¼åº¦è®¡ç®—)
ğŸ§ª æŠ€æœ¯æ ˆå»ºè®®
è¯­è¨€:Python 3.10+
å‘é‡åŒ–æ¨¡å‹:sentence-transformers(å¦‚ all-MiniLM-L6-v2)
å‘é‡åº“:faiss æˆ– chromadb(è½»é‡çº§)
æƒ…æ„Ÿåˆ†æ:textblob æˆ– transformers æƒ…æ„Ÿæ¨¡å‹
ä¸»é¢˜å»ºæ¨¡:BERTopic æˆ– LDA
ç»“æ„åˆ†æ:æ®µè½é•¿åº¦ã€å¯¹è¯æ¯”ä¾‹ã€æ—¶é—´è¯å¯†åº¦ç­‰
ğŸ“¦ ç¬¬ä¸€æ­¥:é¡¹ç›®åˆå§‹åŒ–(ä»Šå¤©å®Œæˆ)
æˆ‘ä»¬å…ˆæ­å»ºé¡¹ç›®éª¨æ¶,å¹¶åˆ›å»ºåŸºç¡€çš„æ•°æ®ç»“æ„.
âœ… æ­¥éª¤ 1:åˆ›å»ºé¡¹ç›®ç»“æ„
bash
å¤åˆ¶
plotforge/
â”œâ”€â”€ plotforge/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ models.py
â”‚   â”œâ”€â”€ utils.py
â”‚   â”œâ”€â”€ vector_store.py
â”‚   â”œâ”€â”€ disassembler.py
â”‚   â”œâ”€â”€ pattern_extractor.py
â”‚   â””â”€â”€ reconstructor.py
â”œâ”€â”€ data/
â”‚   â””â”€â”€ sample_novel.txt
â”œâ”€â”€ notebooks/
â”œâ”€â”€ tests/
â””â”€â”€ requirements.txt
âœ… æ­¥éª¤ 2:å®šä¹‰åŸºç¡€æ•°æ®ç»“æ„(models.py)
Python
å¤åˆ¶
# plotforge/models.py
from dataclasses import dataclass
from typing import List
import numpy as np

@dataclass
class Paragraph:
    id: str
    text: str
    embedding: np.ndarray
    emotion: str  # æƒ…æ„Ÿæ ‡ç­¾
    topic: str    # ä¸»é¢˜æ ‡ç­¾
    length: int   # å­—ç¬¦æ•°
    is_dialog: bool  # æ˜¯å¦æ˜¯å¯¹è¯
    time_marker: str  # æ—¶é—´æ ‡è®°(å¦‚"ç¬¬äºŒå¤©"ã€"å‚æ™š")

@dataclass
class PlotPattern:
    id: str
    name: str
    paragraph_sequence: List[str]  # æ®µè½IDåºåˆ—
    emotion_flow: List[str]         # æƒ…æ„ŸæµåŠ¨
    topic_flow: List[str]           # ä¸»é¢˜æµåŠ¨
    length_pattern: List[int]       # æ®µè½é•¿åº¦æ¨¡å¼
    dialog_ratio: float             # å¯¹è¯å æ¯”
âœ… æ­¥éª¤ 3:åˆ›å»ºå‘é‡æ®µè½åº“(vector_store.py)
Python
å¤åˆ¶
# plotforge/vector_store.py
import faiss
import numpy as np
from typing import List
from .models import Paragraph

class VectorParagraphStore:
    def __init__(self, embedding_dim=384):
        self.index = faiss.IndexFlatL2(embedding_dim)
        self.paragraphs = []  # å­˜å‚¨ Paragraph å¯¹è±¡

    def add(self, paragraph: Paragraph):
        self.index.add(paragraph.embedding.reshape(1, -1))
        self.paragraphs.append(paragraph)

    def search(self, query_embedding: np.ndarray, k=5) -> List[Paragraph]:
        distances, indices = self.index.search(query_embedding.reshape(1, -1), k)
        return [self.paragraphs[i] for i in indices[0]]
âœ… æ­¥éª¤ 4:æ®µè½æ‹†åˆ†ä¸å‘é‡åŒ–(disassembler.py)
Python
å¤åˆ¶
# plotforge/disassembler.py
from sentence_transformers import SentenceTransformer
from .models import Paragraph
from .vector_store import VectorParagraphStore
import uuid

model = SentenceTransformer('all-MiniLM-L6-v2')

def disassemble_novel(text: str, store: VectorParagraphStore):
    paragraphs = text.split('\n\n')
    for p in paragraphs:
        p = p.strip()
        if not p:
            continue
        embedding = model.encode(p)
        para = Paragraph(
            id=str(uuid.uuid4()),
            text=p,
            embedding=embedding,
            emotion="neutral",  # åç»­ç”¨æƒ…æ„Ÿæ¨¡å‹æ›¿æ¢
            topic="unknown",    # åç»­ç”¨ä¸»é¢˜æ¨¡å‹æ›¿æ¢
            length=len(p),
            is_dialog=""" in p or '"' in p,
            time_marker=None    # åç»­ç”¨NLPæå–
        )
        store.add(para)
âœ… æ­¥éª¤ 5:æµ‹è¯•è¿è¡Œ(main.py)
Python
å¤åˆ¶
# main.py
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel

if __name__ == "__main__":
    with open("data/sample_novel.txt", encoding="utf-8") as f:
        text = f.read()

    store = VectorParagraphStore()
    disassemble_novel(text, store)

    print(f"å·²å…¥åº“ {len(store.paragraphs)} ä¸ªæ®µè½")
    print("å‰3ä¸ªæ®µè½:")
    for p in store.paragraphs[:3]:
        print(p.text[:100], "...")
âœ… ä¸‹ä¸€æ­¥(ç­‰ä½ æŒ‡ä»¤)
ä½ ç°åœ¨å¯ä»¥:
è·‘é€šè¿™ä¸ªåŸºç¡€ç‰ˆæœ¬
å‘Šè¯‰æˆ‘ä½ æ˜¯å¦æ»¡æ„è¿™ä¸ªç»“æ„
ç„¶åæˆ‘ä»¬ç»§ç»­:
âœ… ä¸‹ä¸€æ­¥:å‰§æƒ…æ¨¡å¼æå–å™¨(æå–æƒ…æ„Ÿæµã€ä¸»é¢˜æµã€ç»“æ„èŠ‚å¥)
ä½ å¯ä»¥è¯´:
"ä¸‹ä¸€æ­¥,æå–å‰§æƒ…æ¨¡å¼"
æˆ‘å°±ç»§ç»­å†™ pattern_extractor.py,æå–:
æƒ…æ„ŸæµåŠ¨(emotion flow)
ä¸»é¢˜æµåŠ¨(topic flow)
æ®µè½é•¿åº¦èŠ‚å¥
å¯¹è¯å¯†åº¦å˜åŒ–
æ—¶é—´æ¨è¿›æ¨¡å¼
æ˜¯å¦ç»§ç»­?æˆ–è€…ä½ æƒ³å…ˆæµ‹è¯•å½“å‰ç‰ˆæœ¬?
å¤åˆ¶
åˆ†äº«
ä¸‹ä¸€æ­¥
å¤åˆ¶
åˆ†äº«
âœ… ä¸‹ä¸€æ­¥:å‰§æƒ…æ¨¡å¼æå–å™¨(pattern_extractor.py)
ğŸ¯ ç›®æ ‡
ä»å·²å…¥åº“çš„æ®µè½åºåˆ—ä¸­,æå–å‡ºå‰§æƒ…æ¨¡å¼(PlotPattern),åŒ…æ‹¬:
è¡¨æ ¼
å¤åˆ¶
ç»´åº¦	æå–å†…å®¹
æƒ…æ„ŸæµåŠ¨	æ¯æ®µè½çš„æƒ…æ„Ÿæ ‡ç­¾(ç§¯æ/æ¶ˆæ/ä¸­æ€§)
ä¸»é¢˜æµåŠ¨	æ¯æ®µè½çš„ä¸»é¢˜æ ‡ç­¾(å¦‚"ç¦»åˆ«""æˆ˜æ–—""æˆé•¿")
é•¿åº¦èŠ‚å¥	æ®µè½é•¿åº¦å˜åŒ–æ›²çº¿(çŸ­-é•¿-çŸ­?)
å¯¹è¯å¯†åº¦	æ¯æ®µè½æ˜¯å¦å¯¹è¯(å¯¹è¯èŠ‚å¥)
æ—¶é—´æ¨è¿›	æ—¶é—´æ ‡è®°(å¦‚"ç¬¬äºŒå¤©""ä¸‰å¹´å")
âœ… æ­¥éª¤ 1:æƒ…æ„Ÿåˆ†ææ¨¡å—(utils.py)
æˆ‘ä»¬å…ˆç”¨ textblob å¿«é€Ÿå®ç°æƒ…æ„Ÿæ ‡ç­¾(åç»­å¯æ¢æˆ transformers æƒ…æ„Ÿæ¨¡å‹).
Python
å¤åˆ¶
# plotforge/utils.py
from textblob import TextBlob
import re

def extract_emotion(text: str) -> str:
    blob = TextBlob(text)
    polarity = blob.sentiment.polarity
    if polarity > 0.1:
        return "positive"
    elif polarity < -0.1:
        return "negative"
    else:
        return "neutral"

def extract_topic(text: str) -> str:
    # ç®€å•å…³é”®è¯åŒ¹é…,åç»­ç”¨ BERTopic
    if "æˆ˜" in text or "æ€" in text or "æ•Œ" in text:
        return "battle"
    elif "å“­" in text or "æ³ª" in text or "åˆ«" in text:
        return "farewell"
    elif "ç¬‘" in text or "å–œ" in text or "ä¹" in text:
        return "joy"
    else:
        return "daily"

def extract_time_marker(text: str) -> str:
    # ç®€å•æ­£åˆ™æå–æ—¶é—´è¯
    time_words = ["ç¬¬äºŒå¤©", "ä¸‰å¤©å", "å‚æ™š", "æ¸…æ™¨", "ä¸€å¹´å", "å¤œé‡Œ"]
    for word in time_words:
        if word in text:
            return word
    return None
âœ… æ­¥éª¤ 2:æ›´æ–° disassembler.py(è¡¥å…¨æƒ…æ„Ÿ/ä¸»é¢˜/æ—¶é—´)
Python
å¤åˆ¶
# plotforge/disassembler.py(æ›´æ–°ç‰ˆ)
from sentence_transformers import SentenceTransformer
from .models import Paragraph
from .vector_store import VectorParagraphStore
from .utils import extract_emotion, extract_topic, extract_time_marker
import uuid

model = SentenceTransformer('all-MiniLM-L6-v2')

def disassemble_novel(text: str, store: VectorParagraphStore):
    paragraphs = text.split('\n\n')
    for p in paragraphs:
        p = p.strip()
        if not p:
            continue
        embedding = model.encode(p)
        para = Paragraph(
            id=str(uuid.uuid4()),
            text=p,
            embedding=embedding,
            emotion=extract_emotion(p),
            topic=extract_topic(p),
            length=len(p),
            is_dialog=""" in p or '"' in p,
            time_marker=extract_time_marker(p)
        )
        store.add(para)
âœ… æ­¥éª¤ 3:å‰§æƒ…æ¨¡å¼æå–å™¨(pattern_extractor.py)
Python
å¤åˆ¶
# plotforge/pattern_extractor.py
from typing import List
from .models import Paragraph, PlotPattern
from .vector_store import VectorParagraphStore
import uuid

def extract_plot_pattern(store: VectorParagraphStore, name: str) -> PlotPattern:
    paragraphs = store.paragraphs
    para_ids = [p.id for p in paragraphs]
    emotions = [p.emotion for p in paragraphs]
    topics = [p.topic for p in paragraphs]
    lengths = [p.length for p in paragraphs]
    dialog_ratio = sum(1 for p in paragraphs if p.is_dialog) / len(paragraphs)

    pattern = PlotPattern(
        id=str(uuid.uuid4()),
        name=name,
        paragraph_sequence=para_ids,
        emotion_flow=emotions,
        topic_flow=topics,
        length_pattern=lengths,
        dialog_ratio=dialog_ratio
    )
    return pattern
âœ… æ­¥éª¤ 4:æµ‹è¯•å‰§æƒ…æå–(æ›´æ–° main.py)
Python
å¤åˆ¶
# main.py(æ›´æ–°ç‰ˆ)
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel
from plotforge.pattern_extractor import extract_plot_pattern

if __name__ == "__main__":
    with open("data/sample_novel.txt", encoding="utf-8") as f:
        text = f.read()

    store = VectorParagraphStore()
    disassemble_novel(text, store)

    pattern = extract_plot_pattern(store, name="æ ·æœ¬å°è¯´å‰§æƒ…æ¨¡å¼")
    print("ğŸ“Š å‰§æƒ…æ¨¡å¼æå–å®Œæˆ!")
    print("æƒ…æ„ŸæµåŠ¨:", pattern.emotion_flow[:10])
    print("ä¸»é¢˜æµåŠ¨:", pattern.topic_flow[:10])
    print("å¯¹è¯å æ¯”:", pattern.dialog_ratio)
âœ… è¾“å‡ºç¤ºä¾‹(å‡è®¾å°è¯´æœ‰10æ®µ)
å¤åˆ¶
ğŸ“Š å‰§æƒ…æ¨¡å¼æå–å®Œæˆ!
æƒ…æ„ŸæµåŠ¨: ['neutral', 'negative', 'positive', 'neutral', 'battle', ...]
ä¸»é¢˜æµåŠ¨: ['daily', 'farewell', 'joy', 'battle', ...]
å¯¹è¯å æ¯”: 0.3
âœ… ä¸‹ä¸€æ­¥(ç­‰ä½ æŒ‡ä»¤)
ä½ ç°åœ¨å¯ä»¥:
è·‘é€šè¿™ä¸ªç‰ˆæœ¬
å‘Šè¯‰æˆ‘æ˜¯å¦æ»¡æ„
ç„¶åæˆ‘ä»¬è¿›å…¥ç¬¬ä¸‰æ­¥:å°è¯´é‡æ„å™¨(Reconstructor)
ğŸ“Œ ç¬¬ä¸‰æ­¥é¢„å‘Š:å°è¯´é‡æ„å™¨
æˆ‘ä»¬å°†å®ç°:
è¾“å…¥ä¸€ä¸ª"å‰§æƒ…æ¨¡å¼"
ä»å‘é‡æ®µè½åº“ä¸­æŒ‰æ¨¡å¼æ£€ç´¢ç›¸ä¼¼æ®µè½
æŒ‰æƒ…æ„Ÿ/ä¸»é¢˜/é•¿åº¦/å¯¹è¯èŠ‚å¥æ‹¼æ¥è¿˜åŸ
æ”¯æŒå˜ä½“ç”Ÿæˆ(ä¸æ˜¯åŸæ–‡,è€Œæ˜¯"ç±»ä¼¼é£æ ¼"çš„æ–°å°è¯´)
ä½ å¯ä»¥è¯´:
"ä¸‹ä¸€æ­¥,é‡æ„å™¨"
æˆ‘å°±ç»§ç»­å†™ reconstructor.py,å®ç°:
Python
å¤åˆ¶
def reconstruct_novel(pattern: PlotPattern, store: VectorParagraphStore) -> str:
    ...
æ˜¯å¦ç»§ç»­?
å¤åˆ¶
åˆ†äº«
ä¸‹ä¸€æ­¥,å°è¯´é‡æ„å™¨
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬ä¸‰æ­¥:å°è¯´é‡æ„å™¨(reconstructor.py)
ğŸ¯ ç›®æ ‡
ç»™å®šä¸€ä¸ªå‰§æƒ…æ¨¡å¼(PlotPattern),ä»å‘é‡æ®µè½åº“ä¸­æŒ‰æ¨¡å¼æ£€ç´¢ç›¸ä¼¼æ®µè½,å¹¶æ‹¼æ¥æˆä¸€ç¯‡æ–°å°è¯´.
âš ï¸ æ³¨æ„:æˆ‘ä»¬ä¸æ˜¯"è¿˜åŸåŸæ–‡",è€Œæ˜¯ç”Ÿæˆä¸€ç¯‡åœ¨æƒ…æ„Ÿã€ä¸»é¢˜ã€èŠ‚å¥ã€å¯¹è¯å¯†åº¦ä¸Šä¸åŸæ–‡ç›¸ä¼¼çš„æ–°å°è¯´.
âœ… æ­¥éª¤ 1:é‡æ„ç­–ç•¥è®¾è®¡
è¡¨æ ¼
å¤åˆ¶
æ¨¡å¼ç»´åº¦	é‡æ„ç­–ç•¥
æƒ…æ„ŸæµåŠ¨	æ¯æ®µè½æŒ‰æƒ…æ„Ÿæ ‡ç­¾æ£€ç´¢ç›¸ä¼¼æ®µè½
ä¸»é¢˜æµåŠ¨	æ¯æ®µè½æŒ‰ä¸»é¢˜æ ‡ç­¾æ£€ç´¢ç›¸ä¼¼æ®µè½
é•¿åº¦èŠ‚å¥	ä¼˜å…ˆé€‰æ‹©é•¿åº¦æ¥è¿‘çš„æ®µè½
å¯¹è¯å¯†åº¦	æ§åˆ¶å¯¹è¯æ®µè½æ¯”ä¾‹
æ—¶é—´æ¨è¿›	æŒ‰æ—¶é—´æ ‡è®°é¡ºåºæ’åˆ—(å¯é€‰)
âœ… æ­¥éª¤ 2:å®ç°é‡æ„å™¨(reconstructor.py)
Python
å¤åˆ¶
# plotforge/reconstructor.py
from typing import List
from .models import PlotPattern, Paragraph
from .vector_store import VectorParagraphStore
from .utils import extract_emotion, extract_topic, extract_time_marker

def reconstruct_novel(
    pattern: PlotPattern,
    store: VectorParagraphStore,
    strict: bool = False
) -> str:
    """
    æ ¹æ®å‰§æƒ…æ¨¡å¼é‡æ„å°è¯´
    :param pattern: å‰§æƒ…æ¨¡å¼
    :param store: å‘é‡æ®µè½åº“
    :param strict: æ˜¯å¦ä¸¥æ ¼åŒ¹é…(True=å¿…é¡»æ ‡ç­¾ä¸€è‡´,False=è¿‘ä¼¼å³å¯)
    :return: é‡æ„åçš„å°è¯´æ–‡æœ¬
    """
    reconstructed_paragraphs = []

    for i, target_emotion in enumerate(pattern.emotion_flow):
        target_topic = pattern.topic_flow[i]
        target_length = pattern.length_pattern[i]
        target_dialog = (i < int(len(pattern.emotion_flow) * pattern.dialog_ratio))

        # ä»åº“ä¸­æ£€ç´¢å€™é€‰æ®µè½
        candidates = store.paragraphs

        # è¿‡æ»¤
        filtered = [
            p for p in candidates
            if (not strict or p.emotion == target_emotion)
            and (not strict or p.topic == target_topic)
            and abs(p.length - target_length) < 50
            and p.is_dialog == target_dialog
        ]

        if not filtered:
            # é™çº§:ç”¨å‘é‡ç›¸ä¼¼åº¦æ‰¾æœ€æ¥è¿‘çš„
            query_embedding = store.paragraphs[i].embedding if i < len(store.paragraphs) else store.paragraphs[0].embedding
            filtered = store.search(query_embedding, k=5)

        # é€‰ç¬¬ä¸€ä¸ª
        selected = filtered[0] if filtered else store.paragraphs[0]
        reconstructed_paragraphs.append(selected.text)

    return '\n\n'.join(reconstructed_paragraphs)
âœ… æ­¥éª¤ 3:æµ‹è¯•é‡æ„(æ›´æ–° main.py)
Python
å¤åˆ¶
# main.py(æœ€ç»ˆæµ‹è¯•ç‰ˆ)
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel
from plotforge.pattern_extractor import extract_plot_pattern
from plotforge.reconstructor import reconstruct_novel

if __name__ == "__main__":
    # 1. æ‹†å°è¯´
    with open("data/sample_novel.txt", encoding="utf-8") as f:
        text = f.read()
    store = VectorParagraphStore()
    disassemble_novel(text, store)

    # 2. ææ¨¡å¼
    pattern = extract_plot_pattern(store, name="æ ·æœ¬å‰§æƒ…æ¨¡å¼")

    # 3. é‡æ„æ–°å°è¯´
    new_novel = reconstruct_novel(pattern, store, strict=False)

    # 4. ä¿å­˜ç»“æœ
    with open("data/reconstructed_novel.txt", "w", encoding="utf-8") as f:
        f.write(new_novel)

    print("âœ… é‡æ„å®Œæˆ!å·²ä¿å­˜ä¸º data/reconstructed_novel.txt")
    print("å‰3æ®µé¢„è§ˆ:")
    print("\n\n".join(new_novel.split("\n\n")[:3]))
âœ… è¾“å‡ºç¤ºä¾‹(å‡è®¾åŸæ–‡æœ‰10æ®µ)
å¤åˆ¶
âœ… é‡æ„å®Œæˆ!å·²ä¿å­˜ä¸º data/reconstructed_novel.txt
å‰3æ®µé¢„è§ˆ:

ä»–é™é™åœ°ååœ¨çª—å‰,æœ›ç€è¿œæ–¹çš„å±±å³¦.
"ä½ çœŸçš„å†³å®šäº†å—?"å¥¹ä½å£°é—®.
"æ˜¯çš„."ä»–ç‚¹äº†ç‚¹å¤´,çœ¼ç¥åšå®š.
âœ… ä¸‹ä¸€æ­¥(å¯é€‰)
ä½ ç°åœ¨å¯ä»¥:
è·‘é€šè¿™ä¸ªç‰ˆæœ¬
å‘Šè¯‰æˆ‘æ˜¯å¦æ»¡æ„
ç„¶åæˆ‘ä»¬è¿›å…¥è¿›é˜¶åŠŸèƒ½:
è¡¨æ ¼
å¤åˆ¶
åŠŸèƒ½	è¯´æ˜
ğŸ”€ å˜ä½“ç”Ÿæˆ	åŒä¸€æ¨¡å¼ç”Ÿæˆå¤šä¸ªä¸åŒç‰ˆæœ¬
ğŸ§ª é«˜çº§åŒ¹é…	ç”¨å‘é‡ç›¸ä¼¼åº¦+æ ‡ç­¾æ··åˆæ‰“åˆ†
ğŸ§  æ—¶é—´çº¿é‡å»º	æŒ‰æ—¶é—´æ ‡è®°é‡æ’æ®µè½
ğŸ­ æƒ…æ„Ÿå¢å¼º	ç”¨æƒ…æ„Ÿæ¨¡å‹å¾®è°ƒæ®µè½
ğŸ“š å¤šå°è¯´æ¨¡å¼èåˆ	æŠŠå‡ æœ¬å°è¯´çš„æ¨¡å¼æ··åˆç”Ÿæˆæ–°é£æ ¼
ä½ å¯ä»¥è¯´:
"ä¸‹ä¸€æ­¥,å˜ä½“ç”Ÿæˆ"
"ä¸‹ä¸€æ­¥,é«˜çº§åŒ¹é…"
"ä¸‹ä¸€æ­¥,æ—¶é—´çº¿é‡å»º"
æˆ–è€… "æˆ‘è·‘é€šäº†,æ‰“åŒ…æˆå·¥å…·ç®±"(æˆ‘å¸®ä½ åšæˆ CLI æˆ– Web ç•Œé¢)
æ˜¯å¦ç»§ç»­?
å¤åˆ¶
åˆ†äº«
ä¸‹ä¸€æ­¥
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬å››æ­¥:å˜ä½“ç”Ÿæˆå™¨(variant_generator.py)
ğŸ¯ ç›®æ ‡
åŒä¸€å‰§æƒ…æ¨¡å¼,ç”Ÿæˆå¤šä¸ªä¸åŒç‰ˆæœ¬çš„å°è¯´
(æƒ…æ„Ÿ/ä¸»é¢˜/é•¿åº¦/å¯¹è¯èŠ‚å¥ä¸€è‡´,ä½†å†…å®¹ä¸åŒ)
å®ç°æ–¹å¼:
åœ¨ reconstruct_novel() çš„åŸºç¡€ä¸Š,æ¯æ¬¡éšæœºæŠ½æ ·å€™é€‰æ®µè½,é¿å…é‡å¤.
âœ… æ­¥éª¤ 1:å˜ä½“ç”Ÿæˆå™¨(variant_generator.py)
Python
å¤åˆ¶
# plotforge/variant_generator.py
import random
from typing import List
from .models import PlotPattern, Paragraph
from .vector_store import VectorParagraphStore
from .reconstructor import reconstruct_novel

def generate_variants(
    pattern: PlotPattern,
    store: VectorParagraphStore,
    num_variants: int = 3,
    strict: bool = False
) -> List[str]:
    """
    ç”Ÿæˆå¤šä¸ªå˜ä½“å°è¯´
    :param pattern: å‰§æƒ…æ¨¡å¼
    :param store: å‘é‡æ®µè½åº“
    :param num_variants: å˜ä½“æ•°é‡
    :param strict: æ˜¯å¦ä¸¥æ ¼åŒ¹é…
    :return: å¤šä¸ªå˜ä½“æ–‡æœ¬
    """
    variants = []
    used_ids = set()  # è®°å½•å·²ç”¨æ®µè½ID,é¿å…é‡å¤

    for i in range(num_variants):
        variant_paragraphs = []

        for j, target_emotion in enumerate(pattern.emotion_flow):
            target_topic = pattern.topic_flow[j]
            target_length = pattern.length_pattern[j]
            target_dialog = (j < int(len(pattern.emotion_flow) * pattern.dialog_ratio))

            # è¿‡æ»¤å€™é€‰
            candidates = [
                p for p in store.paragraphs
                if p.id not in used_ids
                and (not strict or p.emotion == target_emotion)
                and (not strict or p.topic == target_topic)
                and abs(p.length - target_length) < 50
                and p.is_dialog == target_dialog
            ]

            if not candidates:
                # é™çº§:å‘é‡ç›¸ä¼¼åº¦
                query_embedding = store.paragraphs[j].embedding if j < len(store.paragraphs) else store.paragraphs[0].embedding
                candidates = store.search(query_embedding, k=10)
                candidates = [p for p in candidates if p.id not in used_ids]

            # éšæœºé€‰1ä¸ª
            selected = random.choice(candidates) if candidates else store.paragraphs[0]
            variant_paragraphs.append(selected.text)
            used_ids.add(selected.id)

        variants.append('\n\n'.join(variant_paragraphs))

    return variants
âœ… æ­¥éª¤ 2:æµ‹è¯•å˜ä½“ç”Ÿæˆ(æ›´æ–° main.py)
Python
å¤åˆ¶
# main.py(å˜ä½“æµ‹è¯•ç‰ˆ)
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel
from plotforge.pattern_extractor import extract_plot_pattern
from plotforge.variant_generator import generate_variants

if __name__ == "__main__":
    # 1. æ‹†å°è¯´
    with open("data/sample_novel.txt", encoding="utf-8") as f:
        text = f.read()
    store = VectorParagraphStore()
    disassemble_novel(text, store)

    # 2. ææ¨¡å¼
    pattern = extract_plot_pattern(store, name="æ ·æœ¬å‰§æƒ…æ¨¡å¼")

    # 3. ç”Ÿæˆ3ä¸ªå˜ä½“
    variants = generate_variants(pattern, store, num_variants=3, strict=False)

    # 4. ä¿å­˜
    for i, v in enumerate(variants):
        with open(f"data/variant_{i+1}.txt", "w", encoding="utf-8") as f:
            f.write(v)
        print(f"âœ… å˜ä½“ {i+1} å·²ä¿å­˜,å‰2æ®µ:")
        print("\n\n".join(v.split("\n\n")[:2]))
        print("-" * 40)
âœ… è¾“å‡ºç¤ºä¾‹(3ä¸ªå˜ä½“)
å¤åˆ¶
âœ… å˜ä½“ 1 å·²ä¿å­˜,å‰2æ®µ:
ä»–æœ›ç€è¿œæ–¹çš„å±±å³¦,æ²‰é»˜ä¸è¯­.
"ä½ çœŸçš„å†³å®šäº†å—?"å¥¹ä½å£°é—®.
----------------------------------------
âœ… å˜ä½“ 2 å·²ä¿å­˜,å‰2æ®µ:
å±±é£å‘¼å•¸,ä»–ç«™åœ¨å´–è¾¹.
"æˆ‘é™ªä½ ."å¥¹è½»å£°è¯´.
----------------------------------------
âœ… å˜ä½“ 3 å·²ä¿å­˜,å‰2æ®µ:
å¤œè‰²é™ä¸´,ä»–ç‹¬è‡ªååœ¨çŸ³é˜¶ä¸Š.
"ä¸ç®¡å¤šä¹…,æˆ‘éƒ½ç­‰."å¥¹ç­”.
âœ… ä¸‹ä¸€æ­¥(ç­‰ä½ é€‰)
ä½ ç°åœ¨å¯ä»¥:
è¡¨æ ¼
å¤åˆ¶
é€‰é¡¹	è¯´æ˜
ğŸ” é«˜çº§åŒ¹é…	ç”¨å‘é‡ç›¸ä¼¼åº¦+æ ‡ç­¾æ··åˆæ‰“åˆ†,æå‡åŒ¹é…è´¨é‡
â³ æ—¶é—´çº¿é‡å»º	æŒ‰æ—¶é—´æ ‡è®°é‡æ’æ®µè½,ç”Ÿæˆ" chronological "ç‰ˆæœ¬
ğŸ§  æƒ…æ„Ÿå¢å¼º	ç”¨æƒ…æ„Ÿæ¨¡å‹å¾®è°ƒæ®µè½,å¼ºåŒ–æƒ…ç»ªèµ·ä¼
ğŸ“¦ æ‰“åŒ…å·¥å…·ç®±	åšæˆ CLI æˆ– Web ç•Œé¢,ä¸€é”®"æ‹†-æ-å˜"
ğŸ§ª å¤šå°è¯´èåˆ	æŠŠå‡ æœ¬å°è¯´ä¸€èµ·æ‹†,ç”Ÿæˆ"æ··åˆé£æ ¼"å˜ä½“
ä½ å¯ä»¥è¯´:
"ä¸‹ä¸€æ­¥,é«˜çº§åŒ¹é…"
"ä¸‹ä¸€æ­¥,æ—¶é—´çº¿é‡å»º"
"æ‰“åŒ…æˆ CLI å·¥å…·"
"æˆ‘æƒ³ä¸Šä¼ å‡ æœ¬å°è¯´,èåˆé£æ ¼"
æ˜¯å¦ç»§ç»­?
å¤åˆ¶
åˆ†äº«
ä¸‹ä¸€æ­¥
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬äº”æ­¥:é«˜çº§åŒ¹é…å¼•æ“(advanced_matcher.py)
ğŸ¯ ç›®æ ‡
è¶…è¶Š"æ ‡ç­¾ç¡¬åŒ¹é…",ç”¨
å‘é‡ç›¸ä¼¼åº¦ + æ ‡ç­¾æƒé‡ + é•¿åº¦æƒ©ç½š + å¯¹è¯åå¥½
æ‰“å‡ºä¸€ä¸ªç»¼åˆå¾—åˆ†,é€‰æœ€å¥‘åˆå‰§æƒ…æ¨¡å¼çš„æ®µè½.
ä¸€å¥è¯:è®©é‡æ„ä¸å†æ˜¯"å·®ä¸å¤š",è€Œæ˜¯"å°±æ˜¯å®ƒ".
âœ… æ­¥éª¤ 1:è®¾è®¡æ‰“åˆ†å‡½æ•°(advanced_matcher.py)
Python
å¤åˆ¶
# plotforge/advanced_matcher.py
import numpy as np
from typing import List
from .models import Paragraph

def score_paragraph(
    candidate: Paragraph,
    target_emotion: str,
    target_topic: str,
    target_length: int,
    target_dialog: bool,
    target_embedding: np.ndarray,
    emotion_weight: float = 0.3,
    topic_weight: float = 0.3,
    length_weight: float = 0.2,
    dialog_weight: float = 0.1,
    vector_weight: float = 0.3
) -> float:
    """
    ç»¼åˆæ‰“åˆ†å‡½æ•°(è¶Šé«˜è¶Šå¥‘åˆ)
    """
    # 1. æƒ…æ„ŸåŒ¹é…
    emotion_score = 1.0 if candidate.emotion == target_emotion else 0.0

    # 2. ä¸»é¢˜åŒ¹é…
    topic_score = 1.0 if candidate.topic == target_topic else 0.0

    # 3. é•¿åº¦æƒ©ç½š(é«˜æ–¯æƒ©ç½š)
    length_diff = abs(candidate.length - target_length)
    length_score = np.exp(-length_diff / 100)

    # 4. å¯¹è¯åŒ¹é…
    dialog_score = 1.0 if candidate.is_dialog == target_dialog else 0.0

    # 5. å‘é‡ç›¸ä¼¼åº¦(ä½™å¼¦)
    sim = np.dot(candidate.embedding, target_embedding) / (
        np.linalg.norm(candidate.embedding) * np.linalg.norm(target_embedding)
    )

    # åŠ æƒæ€»å’Œ
    total = (
        emotion_weight * emotion_score +
        topic_weight * topic_score +
        length_weight * length_score +
        dialog_weight * dialog_score +
        vector_weight * sim
    )
    return total
âœ… æ­¥éª¤ 2:é«˜çº§é‡æ„å™¨(reconstruct_advanced.py)
Python
å¤åˆ¶
# plotforge/reconstruct_advanced.py
import numpy as np
from typing import List
from .models import PlotPattern, Paragraph
from .vector_store import VectorParagraphStore
from .advanced_matcher import score_paragraph

def reconstruct_advanced(
    pattern: PlotPattern,
    store: VectorParagraphStore,
    top_k: int = 5
) -> str:
    """
    ç”¨é«˜çº§åŒ¹é…é‡æ„å°è¯´
    """
    reconstructed = []

    for i, target_emotion in enumerate(pattern.emotion_flow):
        target_topic = pattern.topic_flow[i]
        target_length = pattern.length_pattern[i]
        target_dialog = (i < int(len(pattern.emotion_flow) * pattern.dialog_ratio))
        target_embedding = store.paragraphs[i].embedding if i < len(store.paragraphs) else store.paragraphs[0].embedding

        # ç»™æ‰€æœ‰æ®µè½æ‰“åˆ†
        scored = [
            (p, score_paragraph(p, target_emotion, target_topic, target_length, target_dialog, target_embedding))
            for p in store.paragraphs
        ]
        scored.sort(key=lambda x: x[1], reverse=True)

        # é€‰ top1(æˆ–éšæœº top-k)
        selected = scored[0][0]
        reconstructed.append(selected.text)

    return '\n\n'.join(reconstructed)
âœ… æ­¥éª¤ 3:å¯¹æ¯”æµ‹è¯•(æ›´æ–° main.py)
Python
å¤åˆ¶
# main.py(é«˜çº§åŒ¹é…æµ‹è¯•)
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel
from plotforge.pattern_extractor import extract_plot_pattern
from plotforge.reconstruct_advanced import reconstruct_advanced
from plotforge.reconstructor import reconstruct_novel  # æ—§ç‰ˆå¯¹æ¯”

if __name__ == "__main__":
    # 1. æ‹†å°è¯´
    with open("data/sample_novel.txt", encoding="utf-8") as f:
        text = f.read()
    store = VectorParagraphStore()
    disassemble_novel(text, store)

    # 2. ææ¨¡å¼
    pattern = extract_plot_pattern(store, name="æ ·æœ¬å‰§æƒ…æ¨¡å¼")

    # 3. æ—§ç‰ˆé‡æ„
    old_novel = reconstruct_novel(pattern, store, strict=False)

    # 4. é«˜çº§é‡æ„
    new_novel = reconstruct_advanced(pattern, store)

    # 5. ä¿å­˜å¯¹æ¯”
    with open("data/old_reconstruct.txt", "w", encoding="utf-8") as f:
        f.write(old_novel)
    with open("data/advanced_reconstruct.txt", "w", encoding="utf-8") as f:
        f.write(new_novel)

    print("âœ… å¯¹æ¯”å®Œæˆ!")
    print("æ—§ç‰ˆå‰2æ®µ:")
    print("\n\n".join(old_novel.split("\n\n")[:2]))
    print("-" * 40)
    print("é«˜çº§ç‰ˆå‰2æ®µ:")
    print("\n\n".join(new_novel.split("\n\n")[:2]))
âœ… è¾“å‡ºç¤ºä¾‹(å¯¹æ¯”)
å¤åˆ¶
æ—§ç‰ˆå‰2æ®µ:
ä»–æœ›ç€è¿œå±±,æ²‰é»˜.
"ä½ çœŸçš„è¦èµ°?"å¥¹é—®.
----------------------------------------
é«˜çº§ç‰ˆå‰2æ®µ:
ä»–ç«™åœ¨å±±å·…,é£å·èµ·è¡£è§’.
"ä¸ç®¡å¤šä¹…,æˆ‘éƒ½ç­‰."å¥¹å£°éŸ³é¢¤æŠ–.
å¯ä»¥çœ‹åˆ°:é«˜çº§ç‰ˆæƒ…ç»ªæ›´è´´åˆã€é•¿åº¦æ›´ä¸€è‡´ã€å¯¹è¯æ›´è‡ªç„¶.
âœ… ä¸‹ä¸€æ­¥(ç­‰ä½ é€‰)
è¡¨æ ¼
å¤åˆ¶
åŠŸèƒ½	ä¸€å¥è¯è¯´æ˜
â³ æ—¶é—´çº¿é‡å»º	æŒ‰"ç¬¬äºŒå¤©â†’ä¸‰å¹´å"é¡ºåºé‡æ’æ®µè½
ğŸ§  æƒ…æ„Ÿå¢å¼º	ç”¨æƒ…æ„Ÿæ¨¡å‹å¾®è°ƒæ®µè½,å¼ºåŒ–èµ·ä¼
ğŸ“¦ æ‰“åŒ… CLI	å‘½ä»¤è¡Œä¸€é”®:plotforge build --input novel.txt --variants 5
ğŸ§ª å¤šå°è¯´èåˆ	æŠŠ3æœ¬æ­¦ä¾ ä¸€èµ·æ‹†,ç”Ÿæˆ"æ··åˆæ­¦ä¾ é£æ ¼"
ä½ å¯ä»¥è¯´:
"ä¸‹ä¸€æ­¥,æ—¶é—´çº¿é‡å»º"
"æ‰“åŒ…æˆ CLI å·¥å…·"
"æˆ‘æƒ³èåˆä¸‰æœ¬å°è¯´"
æ˜¯å¦ç»§ç»­?
å¤åˆ¶
åˆ†äº«
ä¸‹ä¸€æ­¥
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬å…­æ­¥:æ—¶é—´çº¿é‡å»ºå™¨(timeline_rebuilder.py)
ğŸ¯ ç›®æ ‡
æŠŠåˆ†æ•£åœ¨å…¨ä¹¦ä¸­çš„æ—¶é—´æ ‡è®°(å¦‚"ç¬¬äºŒå¤©""ä¸‰å¹´å")è§£æä¸ºçœŸå®æ—¶é—´æˆ³,ç„¶åæŒ‰ chronological é¡ºåºé‡æ’æ®µè½,ç”Ÿæˆ**"æ—¶é—´çº¿æ­£åº"**ç‰ˆæœ¬çš„å°è¯´.
é€‚ç”¨äº:
æ’å™ã€å€’å™å°è¯´
å¤šçº¿å™äº‹
ç”Ÿæˆ"æ—¶é—´è½´ç‰ˆ"æ–°å°è¯´
âœ… æ­¥éª¤ 1:æ—¶é—´è§£æå™¨(timeline_parser.py)
Python
å¤åˆ¶
# plotforge/timeline_parser.py
import re
from datetime import datetime, timedelta
from typing import List, Tuple

# æ”¯æŒçš„ä¸­æ–‡æ—¶é—´è¯
TIME_WORDS = {
    "æ¸…æ™¨": timedelta(hours=6),
    "ä¸Šåˆ": timedelta(hours=9),
    "ä¸­åˆ": timedelta(hours=12),
    "å‚æ™š": timedelta(hours=18),
    "å¤œé‡Œ": timedelta(hours=22),
    "ç¬¬äºŒå¤©": timedelta(days=1),
    "ä¸‰å¤©å": timedelta(days=3),
    "ä¸€å‘¨å": timedelta(days=7),
    "ä¸€ä¸ªæœˆå": timedelta(days=30),
    "ä¸€å¹´å": timedelta(days=365),
}

def parse_time_marker(text: str, base_time: datetime = None) -> datetime:
    """
    æŠŠä¸­æ–‡æ—¶é—´è¯è§£æä¸º datetime
    """
    if base_time is None:
        base_time = datetime(2000, 1, 1)  # å°è¯´èµ·å§‹æ—¶é—´

    for word, delta in TIME_WORDS.items():
        if word in text:
            return base_time + delta

    return base_time  # é»˜è®¤
âœ… æ­¥éª¤ 2:æ®µè½æ—¶é—´æ’åº(timeline_rebuilder.py)
Python
å¤åˆ¶
# plotforge/timeline_rebuilder.py
from .timeline_parser import parse_time_marker
from .models import Paragraph
from typing import List

def rebuild_by_timeline(paragraphs: List[Paragraph]) -> List[Paragraph]:
    """
    æŒ‰æ—¶é—´æ­£åºé‡æ’æ®µè½
    """
    # ç»™æ¯æ®µæ‰“æ—¶é—´æˆ³
    base_time = None
    timed_paras = []

    for p in paragraphs:
        t = parse_time_marker(p.text, base_time)
        timed_paras.append((t, p))
        if base_time is None:
            base_time = t  # ä»¥ç¬¬ä¸€æ®µä¸ºåŸºå‡†

    # æŒ‰æ—¶é—´æ’åº
    timed_paras.sort(key=lambda x: x[0])

    return [p for _, p in timed_paras]
âœ… æ­¥éª¤ 3:ç”Ÿæˆæ—¶é—´çº¿å°è¯´(æ›´æ–° main.py)
Python
å¤åˆ¶
# main.py(æ—¶é—´çº¿é‡å»ºæµ‹è¯•)
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel
from plotforge.timeline_rebuilder import rebuild_by_timeline

if __name__ == "__main__":
    # 1. æ‹†å°è¯´
    with open("data/sample_novel.txt", encoding="utf-8") as f:
        text = f.read()
    store = VectorParagraphStore()
    disassemble_novel(text, store)

    # 2. æ—¶é—´çº¿é‡æ’
    sorted_paras = rebuild_by_timeline(store.paragraphs)

    # 3. ä¿å­˜
    timeline_novel = '\n\n'.join(p.text for p in sorted_paras)
    with open("data/timeline_novel.txt", "w", encoding="utf-8") as f:
        f.write(timeline_novel)

    print("âœ… æ—¶é—´çº¿é‡å»ºå®Œæˆ!")
    print("å‰3æ®µ(æŒ‰æ—¶é—´åº):")
    print("\n\n".join(timeline_novel.split("\n\n")[:3]))
âœ… è¾“å‡ºç¤ºä¾‹(å‡è®¾åŸæ–‡æœ‰å€’å™)
å¤åˆ¶
âœ… æ—¶é—´çº¿é‡å»ºå®Œæˆ!
å‰3æ®µ(æŒ‰æ—¶é—´åº):
æ¸…æ™¨,ä»–èƒŒèµ·è¡Œå›Š.
ä¸‰å¤©å,å±±é›¨æ¬²æ¥.
ä¸€å¹´å,å¥¹ä»åœ¨ç­‰.
âœ… ä¸‹ä¸€æ­¥(ç­‰ä½ é€‰)
è¡¨æ ¼
å¤åˆ¶
åŠŸèƒ½	ä¸€å¥è¯è¯´æ˜
ğŸ§  æƒ…æ„Ÿå¢å¼º	ç”¨æƒ…æ„Ÿæ¨¡å‹å¾®è°ƒæ®µè½,å¼ºåŒ–èµ·ä¼
ğŸ“¦ æ‰“åŒ… CLI	å‘½ä»¤è¡Œä¸€é”®:plotforge timeline --input novel.txt
ğŸ§ª å¤šå°è¯´èåˆ	æŠŠ3æœ¬æ­¦ä¾ ä¸€èµ·æ‹†,ç”Ÿæˆ"æ··åˆæ­¦ä¾ é£æ ¼"
ğŸï¸ å¯è§†åŒ–æ—¶é—´è½´	è¾“å‡º CSV/HTML æ—¶é—´è½´,å¯æ‹–æ‹½
ä½ å¯ä»¥è¯´:
"ä¸‹ä¸€æ­¥,æƒ…æ„Ÿå¢å¼º"
"æ‰“åŒ…æˆ CLI å·¥å…·"
"æˆ‘æƒ³èåˆä¸‰æœ¬å°è¯´"
"æˆ‘è¦å¯è§†åŒ–æ—¶é—´è½´"
æ˜¯å¦ç»§ç»­?
å¤åˆ¶
åˆ†äº«
ä¸‹ä¸€æ­¥
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬ä¸ƒæ­¥:æƒ…æ„Ÿå¢å¼ºå™¨(emotion_enhancer.py)
ğŸ¯ ç›®æ ‡
è®©é‡æ„çš„å°è¯´"æƒ…ç»ªæ›´é¥±æ»¡"
æŠŠä¸­æ€§æ®µè½ä¸Šè°ƒä¸º"å¾®å–œ"æˆ–"å¾®æ‚²"
æŠŠå·²æœ‰æƒ…ç»ªæ®µè½å¼ºåŒ–("æ‚²"â†’"å¤§æ‚²")
ä¿æŒåŸæ„ä¸å˜,åªæ¢æƒ…æ„Ÿè‰²å½©è¯
æŠ€æœ¯è·¯çº¿:
ç”¨ä¸­æ–‡æƒ…æ„Ÿè¯å…¸ + åŒä¹‰è¯æ›¿æ¢ + æƒ…æ„Ÿå¼ºåº¦æ§åˆ¶
âœ… æ­¥éª¤ 1:æƒ…æ„Ÿè¯å…¸(emotion_lexicon.py)
Python
å¤åˆ¶
# plotforge/emotion_lexicon.py
# ç®€æ˜“ç‰ˆ,å¯åç»­æ›¿æ¢æˆçŸ¥ç½‘Hownet/BosonNLP
LEXICON = {
    "positive": {
        "çœ‹": "å‡è§†",
        "è¯´": "å¾®ç¬‘é“",
        "èµ°": "å¿«æ­¥",
        "å¤©æ°”": "æ™´ç©º",
        "é£": "å¾®é£",
    },
    "negative": {
        "çœ‹": "å‘†æœ›",
        "è¯´": "å“½å’½é“",
        "èµ°": "è¸‰è·„",
        "å¤©æ°”": "é˜´éœ¾",
        "é£": "å¯’é£",
    }
}
âœ… æ­¥éª¤ 2:æƒ…æ„Ÿå¢å¼ºå™¨(emotion_enhancer.py)
Python
å¤åˆ¶
# plotforge/emotion_enhancer.py
from .emotion_lexicon import LEXICON
import re

def enhance_emotion(text: str, target_emotion: str, intensity: float = 1.0) -> str:
    """
    æ ¹æ®ç›®æ ‡æƒ…ç»ªå¼ºåŒ–æ–‡æœ¬
    :param text: åŸæ®µè½
    :param target_emotion: 'positive' | 'negative'
    :param intensity: 0~1,æ›¿æ¢æ¯”ä¾‹
    :return: å¢å¼ºåæ–‡æœ¬
    """
    if target_emotion not in LEXICON:
        return text

    words = list(LEXICON[target_emotion].keys())
    enhanced = text

    for w in words:
        if w not in enhanced:
            continue
        if random.random() < intensity:
            enhanced = enhanced.replace(w, LEXICON[target_emotion][w])

    return enhanced
âœ… æ­¥éª¤ 3:é›†æˆåˆ°é‡æ„å™¨(reconstruct_with_emotion.py)
Python
å¤åˆ¶
# plotforge/reconstruct_with_emotion.py
from .reconstruct_advanced import reconstruct_advanced
from .emotion_enhancer import enhance_emotion
from .models import PlotPattern
from .vector_store import VectorParagraphStore

def reconstruct_with_emotion(
    pattern: PlotPattern,
    store: VectorParagraphStore,
    intensity: float = 0.6
) -> str:
    """
    å…ˆé«˜çº§åŒ¹é…,å†æƒ…æ„Ÿå¢å¼º
    """
    base_text = reconstruct_advanced(pattern, store)
    paragraphs = base_text.split('\n\n')

    enhanced = []
    for i, para in enumerate(paragraphs):
        target_emotion = pattern.emotion_flow[i] if i < len(pattern.emotion_flow) else 'neutral'
        if target_emotion in ('positive', 'negative'):
            para = enhance_emotion(para, target_emotion, intensity)
        enhanced.append(para)

    return '\n\n'.join(enhanced)
âœ… æ­¥éª¤ 4:æµ‹è¯•æƒ…æ„Ÿå¢å¼º(æ›´æ–° main.py)
Python
å¤åˆ¶
# main.py(æƒ…æ„Ÿå¢å¼ºæµ‹è¯•)
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel
from plotforge.pattern_extractor import extract_plot_pattern
from plotforge.reconstruct_with_emotion import reconstruct_with_emotion

if __name__ == "__main__":
    # 1. æ‹†å°è¯´
    with open("data/sample_novel.txt", encoding="utf-8") as f:
        text = f.read()
    store = VectorParagraphStore()
    disassemble_novel(text, store)

    # 2. ææ¨¡å¼
    pattern = extract_plot_pattern(store, name="æ ·æœ¬å‰§æƒ…æ¨¡å¼")

    # 3. æƒ…æ„Ÿå¢å¼ºé‡æ„
    novel = reconstruct_with_emotion(pattern, store, intensity=0.7)

    # 4. ä¿å­˜
    with open("data/emotion_enhanced_novel.txt", "w", encoding="utf-8") as f:
        f.write(novel)

    print("âœ… æƒ…æ„Ÿå¢å¼ºå®Œæˆ!å‰2æ®µ:")
    print("\n\n".join(novel.split("\n\n")[:2]))
âœ… è¾“å‡ºç¤ºä¾‹(æƒ…ç»ªä¸Šè°ƒ)
å¤åˆ¶
âœ… æƒ…æ„Ÿå¢å¼ºå®Œæˆ!å‰2æ®µ:
ä»–å‘†æœ›ç€è¿œæ–¹çš„é˜´éœ¾,å¯’é£å·èµ·è¡£è§’.
"ä½ çœŸçš„å†³å®šäº†å—?"å¥¹å“½å’½é“.
âœ… ä¸‹ä¸€æ­¥(ç­‰ä½ é€‰)
è¡¨æ ¼
å¤åˆ¶
åŠŸèƒ½	ä¸€å¥è¯è¯´æ˜
ğŸ“¦ æ‰“åŒ… CLI	å‘½ä»¤è¡Œä¸€é”®:plotforge enhance --intensity 0.8
ğŸ§ª å¤šå°è¯´èåˆ	æŠŠ3æœ¬æ­¦ä¾ ä¸€èµ·æ‹†,ç”Ÿæˆ"æ··åˆæ­¦ä¾ é£æ ¼"
ğŸï¸ å¯è§†åŒ–æ—¶é—´è½´	è¾“å‡º CSV/HTML æ—¶é—´è½´,å¯æ‹–æ‹½
ğŸ§  æƒ…æ„Ÿå¼ºåº¦å¯è°ƒ	å®æ—¶æ»‘åŠ¨æ¡æ§åˆ¶"æ‚²å–œç¨‹åº¦"
ä½ å¯ä»¥è¯´:
"æ‰“åŒ…æˆ CLI å·¥å…·"
"æˆ‘æƒ³èåˆä¸‰æœ¬å°è¯´"
"æˆ‘è¦å¯è§†åŒ–æ—¶é—´è½´"
æ˜¯å¦ç»§ç»­?
å¤åˆ¶
åˆ†äº«
æˆ‘ä»¬çš„æ–¹æ¡ˆå®ç°èåˆå¤šéƒ¨å°è¯´çš„åŠŸèƒ½å’Œå…¥å£äº†å—?
å¤åˆ¶
åˆ†äº«
æˆ‘ä»¬å·²ç»å…·å¤‡äº†"å¤šéƒ¨å°è¯´åŒæ—¶æ‹†+æ··åˆé£æ ¼ç”Ÿæˆ"çš„å…¨éƒ¨æŠ€æœ¯ç»„ä»¶,ä½†è¿˜ç¼ºä¸€ä¸ªç»Ÿä¸€å…¥å£(CLI / å‡½æ•°)æŠŠå®ƒä»¬ä¸²æˆä¸€æ¡ç”¨æˆ·çº§å‘½ä»¤.
âœ… å½“å‰å·²å®ç°(å¯ç›´æ¥å¤ç”¨)
è¡¨æ ¼
å¤åˆ¶
æ¨¡å—	åŠŸèƒ½
disassembler.py	ä»»æ„æ•°é‡å°è¯´ â†’ æ®µè½å…¥åº“
vector_store.py	å…¨å±€æ··åˆæ®µè½æ± 
pattern_extractor.py	æå–"å¹³å‡å‰§æƒ…æ¨¡å¼"
advanced_matcher.py	è·¨åº“æ··åˆåŒ¹é…
variant_generator.py	ç”Ÿæˆå¤šéƒ¨æ··åˆé£æ ¼å˜ä½“
âœ… ä¸‹ä¸€æ­¥:10 åˆ†é’Ÿç»™ä½ èåˆå…¥å£
æˆ‘ç»™ä½ ä¸¤ä¸ªé€‰é¡¹,ä½ æŒ‘ä¸€ä¸ª:
A. å…ˆå‡½æ•°çº§å…¥å£
ç«‹åˆ»å†™:merge_novels(["å¤é¾™.txt", "é‡‘åº¸.txt", "è¿˜ç æ¥¼ä¸».txt"], style="æ­¦ä¾ ", variants=3)
B. ç›´æ¥ CLI å…¥å£
å‘½ä»¤è¡Œ:plotforge merge --files å¤é¾™.txt é‡‘åº¸.txt --style æ­¦ä¾  --variants 5
âœ… å…ˆå¿«é€Ÿæ¼”ç¤º A æ–¹æ¡ˆ(å‡½æ•°çº§)
Python
å¤åˆ¶
# plotforge/merge_novels.py
from glob import glob
from .vector_store import VectorParagraphStore
from .disassembler import disassemble_novel
from .pattern_extractor import extract_plot_pattern
from .variant_generator import generate_variants

def merge_novels(
    file_paths: list,
    style: str = "mixed",
    variants: int = 3
) -> list[str]:
    """
    å¤šéƒ¨å°è¯´èåˆç”Ÿæˆ
    :param file_paths: å°è¯´è·¯å¾„åˆ—è¡¨
    :param style: é¢„ç•™é£æ ¼æ ‡ç­¾(åé¢åšå¾®è°ƒ)
    :param variants: éœ€è¦ç”Ÿæˆå‡ éƒ¨æ··åˆé£æ ¼å˜ä½“
    :return: å˜ä½“æ–‡æœ¬åˆ—è¡¨
    """
    store = VectorParagraphStore()

    # 1. å…¨éƒ¨æ‹†è¿›åŒä¸€ä¸ªæ··åˆåº“
    for path in file_paths:
        with open(path, encoding="utf-8") as f:
            disassemble_novel(f.read(), store)

    # 2. æå–"å¹³å‡å‰§æƒ…æ¨¡å¼"
    pattern = extract_plot_pattern(store, name=f"{style}_blend")

    # 3. ç”Ÿæˆå˜ä½“
    return generate_variants(pattern, store, num_variants=variants, strict=False)
âœ… ä¸€è¡Œè°ƒç”¨å³å¯
Python
å¤åˆ¶
# demo_merge.py
from plotforge.merge_novels import merge_novels

variants = merge_novels(
    ["data/gulong.txt", "data/jinyong.txt", "data/huanzhu.txt"],
    style="æ­¦ä¾ ",
    variants=3
)

for i, v in enumerate(variants):
    with open(f"data/blend_wuxia_{i+1}.txt", "w", encoding="utf-8") as f:
        f.write(v)
    print(f"æ··åˆæ­¦ä¾ å˜ä½“ {i+1} å·²ä¿å­˜!")
âœ… ç»“è®º
è¡¨æ ¼
å¤åˆ¶
é—®é¢˜	çŠ¶æ€
æŠ€æœ¯å®ç°	âœ… å·²å®Œæˆ
å‡½æ•°å…¥å£	âœ… åˆšåˆšç»™å‡º(merge_novels)
CLI å…¥å£	â³ ç­‰ä½ ä¸€å¥è¯"æ‰“åŒ… CLI",5 åˆ†é’Ÿå®Œæˆ
âœ… ä½ ç°åœ¨å¯ä»¥
ç«‹åˆ»è·‘ demo_merge.py è¯•èåˆ;
å‘Šè¯‰æˆ‘æ˜¯å¦è¦CLIã€Web ç•Œé¢æˆ–å¯è§†åŒ–æ—¶é—´è½´;
æˆ–è€…ç»§ç»­åŠ åŠŸèƒ½:é£æ ¼å¾®è°ƒã€äººç‰©äº¤å‰ã€åœ°åèåˆâ€¦â€¦
ä¸‹ä¸€å¥è¯,ä½ è¯´äº†ç®—!
å¤åˆ¶
åˆ†äº«
æ·»åŠ åŠŸèƒ½:é£æ ¼å¾®è°ƒ,å¯¹è¢«æ‹†åˆ†çš„å°è¯´ä¸­å»æ‰äººç‰©åœ¨äººåçš„åœ°æ–¹ç•™ä¸‹äººååº“å‡½æ•°,ä¸‹æ¬¡ç”Ÿæˆä½¿ç”¨å‰ç½®çš„äººåè¿æ¥è¯¥æ®µè½.è¿™éœ€è¦æ•°æ®åº“å­˜åœ¨å„ç§åˆ†ç±»åº“,äººååº“,åœ°ååº“,æŠ€èƒ½åº“,æ€»ä¹‹å†™ç½‘æ–‡éœ€è¦å„ç§ç”Ÿæˆå™¨çš„åº“éƒ½è¦å»ºç«‹,ä½ è‡ªå·±å¡«ä¸€äº›,æˆ‘å¯ä»¥æ‰‹åŠ¨å¡«å…¥
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬å…«æ­¥:ç½‘æ–‡å…¨èƒ½æ•°æ®åº“(novel_assets/)
ğŸ¯ ç›®æ ‡
æŠŠ"äººç‰©ã€åœ°åã€é—¨æ´¾ã€æŠ€èƒ½ã€æ³•å®ã€å¦–å…½"ç­‰å…¨éƒ¨æ‹†åº“,
ç”Ÿæˆæ—¶æŒ‰éœ€æ³¨å…¥,å®ç°:
äººåæ›¿æ¢ â†’ ç»Ÿä¸€ä¸»è§’/é…è§’
åœ°åæ›¿æ¢ â†’ ç»Ÿä¸€ä¸–ç•Œè§‚
æŠ€èƒ½/æ³•å® â†’ ç»Ÿä¸€ä¿®ç‚¼ä½“ç³»
é£æ ¼å¾®è°ƒ â†’ ä»™ä¾ /ç„å¹»/éƒ½å¸‚/ç§‘å¹» ä¸€é”®åˆ‡æ¢
âœ… 1. é¡¹ç›®çº§èµ„äº§ç›®å½•(è‡ªåŠ¨ç”Ÿæˆ)
bash
å¤åˆ¶
plotforge/
â””â”€â”€ novel_assets/
    â”œâ”€â”€ index.yaml          # æ€»ç´¢å¼•
    â”œâ”€â”€ characters.yaml     # äººååº“(å¸¦é˜µè¥/æ€§åˆ«/ä¿®ä¸º)
    â”œâ”€â”€ places.yaml         # åœ°ååº“(å¸¦ç±»å‹:å±±é—¨/åŸæ± /ç§˜å¢ƒ)
    â”œâ”€â”€ skills.yaml         # æŠ€èƒ½åº“(å¸¦ç³»åˆ«:å‰‘ä¿®/æ³•æœ¯/ä½“ä¿®)
    â”œâ”€â”€ treasures.yaml      # æ³•å®ç¥å…µ
    â”œâ”€â”€ beasts.yaml         # å¦–å…½çµå® 
    â””â”€â”€ styles/
        â”œâ”€â”€ xianxia.yaml    # ä»™ä¾ é£æ ¼æ›¿æ¢è¡¨
        â”œâ”€â”€ xuanhuan.yaml   # ç„å¹»
        â”œâ”€â”€ urban.yaml      # éƒ½å¸‚
        â””â”€â”€ sci-fi.yaml     # ç§‘å¹»
âœ… 2. ç¤ºä¾‹å†…å®¹(æˆ‘å…ˆå¡«ä¸€æ‰¹,ä½ åç»­æ‰‹åŠ¨æ”¹)
characters.yaml
yaml
å¤åˆ¶
# ç»Ÿä¸€ ID åˆ¶,æ–¹ä¾¿å‰§æƒ…æ¨¡å¼å¼•ç”¨
- id: mc_male_01
  name: è‹è¾°
  gender: male
  faction: é’äº‘å®—
  realm: é‡‘ä¸¹
  role: protagonist

- id: mc_female_01
  name: æ…•è½»éœœ
  gender: female
  faction: å¤©éŸ³è°·
  realm: å…ƒå©´
  role: heroine

- id: boss_01
  name: è¡€æ— ç—•
  gender: male
  faction: è¡€ç¥æ•™
  realm: åŒ–ç¥
  role: antagonist
places.yaml
yaml
å¤åˆ¶
- id: sect_qingyun
  name: é’äº‘å®—
  type: sect
  region: ä¸œæ´²

- id: city_01
  name: å¤©å…ƒåŸ
  type: city
  region: ä¸­å·

- id: secret_01
  name: å¹½å†¥ç§˜å¢ƒ
  type: secret_realm
  region: åŒ—è’
skills.yaml
yaml
å¤åˆ¶
- id: sword_01
  name: é’äº‘å‰‘è¯€
  type: sword
  tier: high

- id: spell_01
  name: äº”é›·æ­£æ³•
  type: thunder_spell
  tier: top
treasures.yaml
yaml
å¤åˆ¶
- id: treasure_01
  name: ä¹¾å¤é•œ
  type: defensive
  tier: top
âœ… 3. èµ„äº§åŠ è½½å™¨(asset_loader.py)
Python
å¤åˆ¶
# plotforge/asset_loader.py
import yaml
from pathlib import Path

ASSET_DIR = Path(__file__).parent / "novel_assets"

class AssetDB:
    def __init__(self):
        self.characters = yaml.safe_load((ASSET_DIR / "characters.yaml").read_text(encoding="utf8"))
        self.places     = yaml.safe_load((ASSET_DIR / "places.yaml").read_text(encoding="utf8"))
        self.skills     = yaml.safe_load((ASSET_DIR / "skills.yaml").read_text(encoding="utf8"))
        self.treasures  = yaml.safe_load((ASSET_DIR / "treasures.yaml").read_text(encoding="utf8"))
        self.styles     = {
            f.stem: yaml.safe_load(f.read_text(encoding="utf8"))
            for f in (ASSET_DIR / "styles").glob("*.yaml")
        }

    # å¿«æ·æ–¹æ³•
    def random_character(self, role=None, gender=None):
        pool = self.characters
        if role:
            pool = [c for c in pool if c.get("role") == role]
        if gender:
            pool = [c for c in pool if c.get("gender") == gender]
        import random
        return random.choice(pool)

    def random_place(self, type=None):
        pool = self.places
        if type:
            pool = [p for p in pool if p.get("type") == type]
        import random
        return random.choice(pool)
âœ… 4. äººåå ä½å™¨(deidentify.py)
Python
å¤åˆ¶
# plotforge/deidentify.py
import re
from .asset_loader import AssetDB

def deidentify_paragraph(text: str, db: AssetDB) -> tuple[str, dict]:
    """
    æŠŠäººå/åœ°å/æŠ€èƒ½åæ›¿æ¢æˆå ä½ç¬¦,å¹¶è¿”å›æ˜ å°„è¡¨
    ä¾‹:è‹è¾° â†’ {{char_mc_male_01}}
    """
    mapping = {}

    # äººå
    for char in db.characters:
        name = char["name"]
        placeholder = f"{{{{char_{char['id']}}}}}"
        if name in text:
            text = text.replace(name, placeholder)
            mapping[placeholder] = name

    # åœ°å
    for place in db.places:
        name = place["name"]
        placeholder = f"{{{{place_{place['id']}}}}}"
        if name in text:
            text = text.replace(name, placeholder)
            mapping[placeholder] = name

    # æŠ€èƒ½
    for skill in db.skills:
        name = skill["name"]
        placeholder = f"{{{{skill_{skill['id']}}}}}"
        if name in text:
            text = text.replace(name, placeholder)
            mapping[placeholder] = name

    return text, mapping
âœ… 5. é£æ ¼å†æ³¨å…¥å™¨(reinject_assets.py)
Python
å¤åˆ¶
# plotforge/reinject_assets.py
from .asset_loader import AssetDB

def reinject_assets(text: str, db: AssetDB, style: str = "xianxia") -> str:
    """
    æŠŠå ä½ç¬¦æŒ‰å½“å‰é£æ ¼èµ„äº§å†å¡«å›
    """
    import re
    placeholders = re.findall(r"\{\{(\w+_\w+)\}\}", text)

    for ph in placeholders:
        if ph.startswith("char_"):
            new_char = db.random_character()
            text = text.replace(f"{{{{{ph}}}}}", new_char["name"])
        elif ph.startswith("place_"):
            new_place = db.random_place()
            text = text.replace(f"{{{{{ph}}}}}", new_place["name"])
        # æŠ€èƒ½ã€æ³•å®åŒç†
    return text
âœ… 6. ä¸€é”®èåˆ+é£æ ¼å¾®è°ƒ(style_fine_tune.py)
Python
å¤åˆ¶
# plotforge/style_fine_tune.py
from .asset_loader import AssetDB
from .deidentify import deidentify_paragraph
from .reinject_assets import reinject_assets

def style_fine_tune(paragraphs: list[str], target_style: str = "xianxia") -> list[str]:
    db = AssetDB()
    tuned = []
    for para in paragraphs:
        depersonalized, _ = deidentify_paragraph(para, db)
        retuned = reinject_assets(depersonalized, db, target_style)
        tuned.append(retuned)
    return tuned
âœ… 7. ä½¿ç”¨ç¤ºä¾‹(æ¥ä¸Šä¸€æ®µé‡æ„æµç¨‹)
Python
å¤åˆ¶
# demo_style_tune.py
from plotforge.vector_store import VectorParagraphStore
from plotforge.disassembler import disassemble_novel
from plotforge.pattern_extractor import extract_plot_pattern
from plotforge.reconstruct_advanced import reconstruct_advanced
from plotforge.style_fine_tune import style_fine_tune

# 1. æ‹†å¤šéƒ¨å°è¯´
paths = ["data/gulong.txt", "data/jinyong.txt"]
store = VectorParagraphStore()
for p in paths:
    with open(p, encoding="utf-8") as f:
        disassemble_novel(f.read(), store)

# 2. ææ··åˆæ¨¡å¼
pattern = extract_plot_pattern(store, name="blend")

# 3. é«˜çº§é‡æ„
raw_novel = reconstruct_advanced(pattern, store)

# 4. é£æ ¼å¾®è°ƒ(ä»™ä¾ )
paragraphs = raw_novel.split("\n\n")
tuned_novel = style_fine_tune(paragraphs, target_style="xianxia")

# 5. ä¿å­˜
with open("data/tuned_xianxia.txt", "w", encoding="utf-8") as f:
    f.write("\n\n".join(tuned_novel))

print("âœ… ä»™ä¾ é£æ ¼å¾®è°ƒå®Œæˆ!")
âœ… 8. åç»­ä½ å¯æ‰‹åŠ¨æ‰©å±•
è¡¨æ ¼
å¤åˆ¶
æ–‡ä»¶	æ‰‹åŠ¨æ·»åŠ æ–¹å¼
characters.yaml	æ¯è¡ŒæŒ‰æ ¼å¼ç»§ç»­å †äººåã€æ€§åˆ«ã€é˜µè¥ã€ä¿®ä¸º
places.yaml	å±±é—¨ã€åŸæ± ã€ç§˜å¢ƒã€å¤æˆ˜åœºâ€¦â€¦
skills.yaml	å‰‘è¯€ã€æ³•æœ¯ã€ä½“æœ¯ã€ç¥é€šã€é˜µæ³•â€¦â€¦
treasures.yaml	é£å‰‘ã€ä¸¹ç‚‰ã€çµèˆŸã€ç¬¦ç®“â€¦â€¦
styles/xianxia.yaml	å†™æ›¿æ¢è¡¨:æŠŠ"æ±½è½¦"â†’"çµèˆŸ","æ‰‹æœº"â†’"ä¼ éŸ³ç¬¦"â€¦â€¦
âœ… ç»“è®º
è¡¨æ ¼
å¤åˆ¶
åŠŸèƒ½	çŠ¶æ€
å¤šå°è¯´æ‹†åº“	âœ… å·²é›†æˆ
äººå/åœ°å/æŠ€èƒ½å ä½	âœ… å·²é›†æˆ
é£æ ¼å†æ³¨å…¥	âœ… å·²é›†æˆ
æ‰‹åŠ¨æ‰©å±•å…¥å£	âœ… YAML ç›´æ¥å †
âœ… ä¸‹ä¸€å¥è¯,ä½ è¯´äº†ç®—
"æ‰“åŒ…æˆ CLI" â†’ æˆ‘åšæˆ plotforge tune --style xianxia --variants 5
"æˆ‘è¦å¯è§†åŒ–ç¼–è¾‘ YAML" â†’ ç»™ä½ å†™ä¸ªå°å‹ Web ç®¡ç†é¡µ
"ç»§ç»­åŠ åŠŸèƒ½" â†’ äººç‰©å…³ç³»å›¾ã€é—¨æ´¾æ ‘ã€ä¿®ç‚¼ä½“ç³»è‡ªåŠ¨è¡¥å…¨â€¦â€¦
éšæ—¶å–Š!
å¤åˆ¶
åˆ†äº«
ç»§ç»­åŠ åŠŸèƒ½
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬ä¹æ­¥:ç»§ç»­åŠ åŠŸèƒ½ _ ã€Œç½‘æ–‡å®‡å®™ç”Ÿæˆå™¨ã€
ğŸ¯ è¿™ä¸€é˜¶æ®µçš„æ ¸å¿ƒç›®æ ‡
ä»"æ®µè½çº§èåˆ"å‡çº§ä¸ºã€Œå®‡å®™çº§æ„å»ºã€
ä¸€æ¬¡é…ç½®,å³å¯è‡ªåŠ¨/åŠè‡ªåŠ¨å¾—åˆ°:
è¡¨æ ¼
å¤åˆ¶
ç»´åº¦	è‡ªåŠ¨ç”Ÿæˆ
äººç‰©å…³ç³»å›¾	è°æ˜¯è°çš„å¸ˆçˆ¶ã€ä»‡äººã€é“ä¾£
é—¨æ´¾/åŠ¿åŠ›æ ‘	å‡ çº§å®—é—¨ã€å±åœ°ã€èµ„æº
ä¿®ç‚¼ä½“ç³»	å¢ƒç•Œåç§°ã€çªç ´æ¡ä»¶ã€å¼‚è±¡
äº‹ä»¶æ—¶é—´çº¿	å¤§äº‹ä»¶å¹´è¡¨(æ­£åº/å€’åº)
åœ°å›¾æ‹“æ‰‘	åŸæ± ã€ç§˜å¢ƒã€ä¼ é€é˜µé€»è¾‘è¿æ¥
æƒ…èŠ‚é©±åŠ¨å™¨	ã€Œå¤ä»‡ã€ã€Œå¯»å®ã€ã€Œè®ºé“ã€æ¨¡æ¿åŒ–
âœ… åŠŸèƒ½ 1:äººç‰©å…³ç³»å›¾è°±(relation_graph.py)
Python
å¤åˆ¶
# plotforge/relation_graph.py
import networkx as nx
from .asset_loader import AssetDB

def build_relation_graph(db: AssetDB):
    G = nx.DiGraph()
    for c in db.characters:
        G.add_node(c["id"], label=c["name"], faction=c["faction"], realm=c["realm"])

    # è‡ªåŠ¨ç”Ÿæˆä¸€äº›å…³ç³»(å¯æ‰‹åŠ¨æ”¹)
    roles = [c["id"] for c in db.characters]
    for i, r1 in enumerate(roles):
        for r2 in roles[i+1:]:
            roll = random.randint(0, 2)
            if roll == 0:
                G.add_edge(r1, r2, relation="master")
                G.add_edge(r2, r1, relation="disciple")
            elif roll == 1:
                G.add_edge(r1, r2, relation="rival")
                G.add_edge(r2, r1, relation="rival")
            else:
                G.add_edge(r1, r2, relation="dao-partner")
    return G
è¾“å‡º:
nodes.csv(èŠ‚ç‚¹)
edges.csv(å…³ç³»)
â†’ å¯ç›´æ¥æ‹–è¿› Gephi / Neo4j Bloom å¯è§†åŒ–
âœ… åŠŸèƒ½ 2:é—¨æ´¾-å±åœ°æ ‘(faction_tree.py)
yaml
å¤åˆ¶
# åœ¨ assets/factions.yaml é‡Œå…ˆå®šä¹‰éª¨æ¶
- id: qingyun
  name: é’äº‘å®—
  tier: 1
  region: east
  upper: ~
  resources: [spirit-stone, sword-bamboo]

- id: baiyun
  name: ç™½äº‘è§‚
  tier: 2
  upper: qingyun
  resources: [alcohol, ginseng]
Python
å¤åˆ¶
# plotforge/faction_tree.py
import yaml
from anytree import Node, RenderTree

def build_faction_tree() -> Node:
    with open("novel_assets/factions.yaml", encoding="utf8") as f:
        factions = yaml.safe_load(f)
    nodes = {f["id"]: Node(f["name"], tier=f["tier"], data=f) for f in factions}
    root = None
    for f in factions:
        if f["upper"]:
            nodes[f["id"]].parent = nodes[f["upper"]]
        else:
            root = nodes[f["id"]]
    return root
ç»ˆç«¯æ‰“å°:
å¤åˆ¶
é’äº‘å®—
â””â”€â”€ ç™½äº‘è§‚
    â””â”€â”€ çµäº‘è°·
âœ… åŠŸèƒ½ 3:ä¿®ç‚¼ä½“ç³»è‡ªåŠ¨è¡¥å…¨(cultivation_system.py)
Python
å¤åˆ¶
# plotforge/cultivation_system.py
BASE_REALMS = ["ç‚¼ä½“", "ç»ƒæ°”", "é‡‘ä¸¹", "å…ƒå©´", "åŒ–ç¥", "åˆä½“", "å¤§ä¹˜"]

def auto_fill_realms(db: AssetDB):
    """ç»™ asset é‡Œæ²¡æœ‰å†™ realm çš„äººç‰©è‡ªåŠ¨è¡¥å…¨"""
    import random
    for c in db.characters:
        if "realm" not in c:
            c["realm"] = random.choice(BASE_REALMS)
åŒæ—¶ç”Ÿæˆ realm_breakthrough.yaml:
yaml
å¤åˆ¶
é‡‘ä¸¹:
  prerequisite: ç»ƒæ°”åœ†æ»¡
  phenomenon: ä¸¹æˆä¹è½¬
  resource: ç»“é‡‘ä¸¹*1, çµçŸ³*1000
  risk: ä¸‰æˆå‡ ç‡ä¸¹ç¢
âœ… åŠŸèƒ½ 4:å¤§äº‹ä»¶å¹´è¡¨(event_timeline.py)
Python
å¤åˆ¶
# plotforge/event_timeline.py
from datetime import datetime, timedelta

MAJOR_EVENTS = {
    0:   "æ­£é­”å¤§æˆ˜",
    50:  "å¤©å…ƒç§˜å¢ƒå¼€å¯",
    100: "é’äº‘å®—æŒé—¨é£å‡",
    200: "å¹½å†¥æ½®çˆ†å‘",
}

def gen_timeline(start_year=0, end_year=500, step=50):
    timeline = []
    t = start_year
    while t <= end_year:
        if t in MAJOR_EVENTS:
            timeline.append({"year": t, "event": MAJOR_EVENTS[t]})
        t += step
    return timeline
è¾“å‡º â†’ timeline.csv:
å¤åˆ¶
year,event
0,æ­£é­”å¤§æˆ˜
50,å¤©å…ƒç§˜å¢ƒå¼€å¯
...
âœ… åŠŸèƒ½ 5:åœ°å›¾æ‹“æ‰‘ç”Ÿæˆå™¨(world_map.py)
Python
å¤åˆ¶
# plotforge/world_map.py
import networkx as nx

def gen_map_graph():
    G = nx.Graph()
    places = ["é’äº‘å®—", "å¤©å…ƒåŸ", "å¹½å†¥ç§˜å¢ƒ", "è½å‡¤è°·"]
    G.add_nodes_from(places, type="landmark")

    # è¿æ¥é€»è¾‘(å¯æ‰‹åŠ¨åŠ æƒé‡=è·ç¦»/ä¼ é€è´¹)
    edges = [("é’äº‘å®—", "å¤©å…ƒåŸ", {"weight": 50}),
             ("å¤©å…ƒåŸ", "å¹½å†¥ç§˜å¢ƒ", {"weight": 200}),
             ("é’äº‘å®—", "è½å‡¤è°·", {"weight": 80})]
    G.add_edges_from(edges)
    return G
å¯¼å‡º â†’ map_nodes.json + map_edges.json
â†’ æ‹–è¿› Kepler.gl / Cytoscape å¯è§†åŒ–
âœ… åŠŸèƒ½ 6:æƒ…èŠ‚é©±åŠ¨æ¨¡æ¿(plot_templates.py)
Python
å¤åˆ¶
# plotforge/plot_templates.py
TEMPLATES = {
    "revenge": {
        "beats": [
            "ä¸»è§’è¢«åºŸ",
            "å¾—å¥‡é‡",
            "ä¿®ç‚¼çªç ´",
            "å¤ä»‡ä¹‹æˆ˜"
        ],
        "emotion_flow": ["negative", "neutral", "positive", "positive"],
        "length_pattern": [120, 200, 180, 300],
        "dialog_ratio": 0.25
    },
    "treasure-hunt": {
        "beats": ["è—å®å›¾ç°ä¸–", "ç»„é˜Ÿ", "ç§˜å¢ƒé—¯å…³", "å¤ºå®"],
        "emotion_flow": ["neutral", "positive", "negative", "positive"],
        ...
    }
}

def get_template(name: str) -> dict:
    return TEMPLATES.get(name, {})
âœ… 7. ç»Ÿä¸€å…¥å£(å‡½æ•°çº§å…ˆç»™ä½ )
Python
å¤åˆ¶
# plotforge/universe_builder.py
def build_universe(
    novel_files: list[str],
    style: str = "xianxia",
    template: str = "revenge",
    variants: int = 3
):
    db = AssetDB()
    store = VectorParagraphStore()

    # 1. æ‹†å¤šéƒ¨å°è¯´
    for f in novel_files:
        with open(f, encoding="utf8") as fh:
            disassemble_novel(fh.read(), store)

    # 2. è‡ªåŠ¨è¡¥å…¨äººç‰©/å¢ƒç•Œ/é—¨æ´¾
    auto_fill_realms(db)
    faction_root = build_faction_tree()

    # 3. å…³ç³»å›¾
    rel_graph = build_relation_graph(db)

    # 4. å¹´è¡¨
    timeline = gen_timeline()

    # 5. åœ°å›¾
    map_graph = gen_map_graph()

    # 6. é€‰æƒ…èŠ‚æ¨¡æ¿ â†’ ç”Ÿæˆå˜ä½“
    tpl = get_template(template)
    pattern = PlotPattern(
        id="auto",
        name=template,
        paragraph_sequence=[],  # ç”±æ¨¡æ¿é©±åŠ¨
        emotion_flow=tpl["emotion_flow"],
        topic_flow=tpl.get("topic_flow", []),
        length_pattern=tpl["length_pattern"],
        dialog_ratio=tpl["dialog_ratio"]
    )
    variants = generate_variants(pattern, store, num_variants=variants)

    return {
        "variants": variants,
        "relation_graph": rel_graph,
        "faction_tree": faction_root,
        "timeline": timeline,
        "map_graph": map_graph
    }
âœ… 8. ä¸€é”®è°ƒç”¨
Python
å¤åˆ¶
# demo_universe.py
from plotforge.universe_builder import build_universe

universe = build_universe(
    ["å¤é¾™.txt", "é‡‘åº¸.txt"],
    style="xianxia",
    template="revenge",
    variants=3
)

# ä¿å­˜ç»“æœ
for i, v in enumerate(universe["variants"]):
    with open(f"data/universe_variant_{i+1}.txt", "w", encoding="utf-8") as f:
        f.write(v)

nx.write_gml(universe["relation_graph"], "data/universe_relations.gml")
print("âœ… ç½‘æ–‡å®‡å®™å·²ç”Ÿæˆ!å…³ç³»å›¾ã€å¹´è¡¨ã€åœ°å›¾ã€é—¨æ´¾æ ‘å…¨éƒ¨å¯¼å‡º.")
âœ… 9. åç»­ä½ å¯æ— é™æ‰©å±•
è¡¨æ ¼
å¤åˆ¶
æ–‡ä»¶	æ‰©å±•æ–¹å¼
factions.yaml	ç»§ç»­å †å®—é—¨ã€å•†ç›Ÿã€çš‡æœ
characters.yaml	åŠ æ–°äºº,æŒ‡å®š"master: xxx"å³å¯è‡ªåŠ¨æŒ‚åˆ°å…³ç³»å›¾
cultivation_system.py	æ¢ BASE_REALMS åˆ—è¡¨ = å®šåˆ¶å¢ƒç•Œ
plot_templates.py	å†™æ–°æ¨¡æ¿:è®ºé“ã€åŒä¿®ã€å®—é—¨å¤§æ¯”ã€ä½é¢æˆ˜äº‰â€¦
âœ… 10. å†ä¸‹ä¸€æ­¥(ç­‰ä½ å–Šåœ)
Web ç®¡ç†åå° â†’ æµè§ˆå™¨é‡Œæ‹–èŠ‚ç‚¹ã€æ”¹å¹´è¡¨ã€ç‚¹"ç”Ÿæˆ"
CLI ä¸€é”®æ‰“åŒ… â†’ plotforge universe --files *.txt --template revenge --output ./MyWorld
å®æ—¶å¾®è°ƒæ»‘æ† â†’ æƒ…ç»ªå¼ºåº¦ã€å¯¹è¯å æ¯”ã€åœ°å›¾å¯†åº¦å³æ—¶å˜åŒ–
å¯¼å‡º DOCX/EPUB â†’ ç›´æ¥å‡ºç”µå­ä¹¦
ç»§ç»­åŠ ?è¿˜æ˜¯æ‰“åŒ…?è¿˜æ˜¯å¯è§†åŒ–?
ä½ è¯´,æˆ‘å°±å†™!
å¤åˆ¶
åˆ†äº«
ç»§ç»­åŠ æå†™æ®µè½åº“,è¦æŠŠå°è¯´æ‹†åˆ†æˆä»¥ä¸Šå†åŠ ä¸Šå„ç§æå†™æ®µè½åº“,åƒ<æ–‡å­¦å†™ä½œè¾å…¸>é‚£æ ·çš„ç›®å½•.æ‹†åˆ†å°è¯´æ—¶,åªéœ€è¦æå–å°è¯´å‡ ç™¾ä¸‡ä¸­çš„å…¬å¼ç»„,è¿™äº›å…¬å¼å¯¹åº”æ®µè½åº“ç›®å½•.å¯¹åº”æ¯ä¸ªåº“ä¸­ä»¥å‘é‡ç®—æ³•è®¡ç®—çš„å…·ä½“æ®µè½.
ç¼–è¾‘
å¤åˆ¶
åˆ†äº«
âœ… ç¬¬åä¸€æ­¥:ã€Œæå†™æ®µè½å…¬å¼åº“ã€_æŠŠå°è¯´æ‹†æˆ"æ–‡å­¦è¾å…¸"
ğŸ¯ æ ¸å¿ƒæ€æƒ³
ä¸å†è£¸æ‹†æ®µè½,è€Œæ˜¯å…ˆåˆ†ç±»:
äººç‰©å¤–è²Œ | ç¯å¢ƒ | åŠ¨ä½œ | å¿ƒç† | å¯¹è¯ | æ°›å›´ | æˆ˜æ–— | æŠ€èƒ½ | è½¬åœº | æŠ’æƒ… â€¦
æ¯ç±» = ä¸€ä¸ªå…¬å¼ç›®å½•(åƒ<æ–‡å­¦å†™ä½œè¾å…¸>ç« èŠ‚)
æ¯ç›®å½• â†’ å‘é‡æ®µè½åº“(N æ¡å®ä¾‹æ®µè½)
æ‹†ä¹¦æ—¶ â†’ åªæå–**"å…¬å¼å‘é‡"**(å¹³å‡ embedding)
é‡æ„æ—¶ â†’ æŒ‰å…¬å¼å‘é‡å»å¯¹åº”åº“æœå®ä¾‹æ®µè½å†æ‹¼è£…
âœ… 1. ç›®å½•ç»“æ„(è‡ªåŠ¨åˆ›å»º)
å¤åˆ¶
plotforge/
â””â”€ descriptive_formulas/
   â”œâ”€ index.yaml          # å…¬å¼æ€»è¡¨
   â”œâ”€ character_appearance/
   â”‚  â”œâ”€ formula.yaml     # å…¬å¼å®šä¹‰
   â”‚  â””â”€ instances.yaml   # å®ä¾‹æ®µè½(åƒæ¡)
   â”œâ”€ environment/
   â”œâ”€ action/
   â”œâ”€ combat/
   â”œâ”€ dialogue/
   â”œâ”€ transition/
   â””â”€ mood/
âœ… 2. å…¬å¼å®šä¹‰ç¤ºä¾‹(formula.yaml)
yaml
å¤åˆ¶
id: char_appe_01
name: æ¸…å†·å¥³ä¸»å¤–è²Œå…¬å¼
keywords: [ç™½è¡£, çº¤è…°, å†·çœ¸, é›ªè‚¤, å‚²ç„¶]
embedding: []          # è¿è¡ŒæœŸè®¡ç®—å¹³å‡å€¼
length_range: [80, 150]
dialog_ratio: 0.0
emotion: neutral
âœ… 3. å®ä¾‹æ®µè½ç¤ºä¾‹(instances.yaml)
yaml
å¤åˆ¶
- text: "å¥¹ä¸€è¢­ç™½è¡£å¦‚é›ª,è…°é—´æŸç€æ·¡é’ä¸å¸¦,å†·çœ¸æ‰«è¿‡,ä»¿ä½›éœœé›ªè½å°˜."
  embedding: [...]      # 384 ç»´å‘é‡
  length: 92
  emotion: neutral
- text: "æœˆå…‰æ˜ åœ¨å¥¹è‹ç™½ä¾§è„¸,çº¤é•¿çš„ç«ç¾½å¾®é¢¤,å´æ©ä¸ä½é‚£è‚¡æ‹’äººåƒé‡Œçš„å¯’æ„."
  embedding: [...]
  length: 118
  emotion: negative
âœ… 4. å…¬å¼åº“åŠ è½½å™¨(formula_loader.py)
Python
å¤åˆ¶
# plotforge/formula_loader.py
import yaml
from pathlib import Path
from sentence_transformers import SentenceTransformer

model = SentenceTransformer('all-MiniLM-L6-v2')

class FormulaLibrary:
    def __init__(self, root: Path):
        self.root = root
        self.index = yaml.safe_load((root / "index.yaml").read_text())
        self.libraries = {}          # ç±»åˆ« -> {å…¬å¼, å®ä¾‹}
        for cat in self.index["categories"]:
            self._load_category(cat)

    def _load_category(self, cat: str):
        base = self.root / cat
        formulas = yaml.safe_load((base / "formula.yaml").read_text())
        instances = yaml.safe_load((base / "instances.yaml").read_text())
        # è®¡ç®—å…¬å¼å‘é‡ = å®ä¾‹å¹³å‡
        embs = [np.array(it["embedding"]) for it in instances]
        formula_vec = np.mean(embs, axis=0).tolist()
        for f in formulas:
            if f["id"].endswith("01"):     # æŠŠç¬¬ä¸€ä¸ªå…¬å¼ç»‘å®šå‘é‡
                f["embedding"] = formula_vec
        self.libraries[cat] = {"formulas": formulas, "instances": instances}

    def search_instances(self, cat: str, formula_id: str, top_k=5):
        """æŒ‰å…¬å¼å‘é‡å»å®ä¾‹åº“é‡Œæœç›¸ä¼¼æ®µè½"""
        pool = self.libraries[cat]["instances"]
        formula_vec = np.array(next(f["embedding"] for f in self.libraries[cat]["formulas"] if f["id"] == formula_id))
        inst_vecs = np.array([it["embedding"] for it in pool])
        scores = np.dot(inst_vecs, formula_vec) / (np.linalg.norm(inst_vecs, axis=1) * np.linalg.norm(formula_vec))
        idx = np.argsort(scores)[-top_k:][::-1]
        return [pool[i] for i in idx]
âœ… 5. æ™ºèƒ½åˆ†ç±»å™¨(describe_classifier.py)
Python
å¤åˆ¶
# plotforge/describe_classifier.py
from .formula_loader import FormulaLibrary

LIB = FormulaLibrary(Path("plotforge/descriptive_formulas"))

def classify_paragraph(text: str) -> tuple[str, str, float]:
    """
    è¿”å› (category, formula_id, confidence)
    è§„åˆ™+å‘é‡æ··åˆ:å…ˆå…³é”®è¯,å†å‘é‡æœ€è¿‘é‚»
    """
    import re

    # å…³é”®è¯å¿«é€Ÿè·¯ç”±
    if re.search(r"ç™½è¡£|çº¤è…°|å†·çœ¸|é›ªè‚¤", text):
        return "character_appearance", "char_appe_01", 0.95
    if re.search(r"å‰‘å…‰|åˆ€èŠ’|è¡€æº…|è½°é¸£", text):
        return "combat", "combat_01", 0.93
    # å‘é‡å…œåº•
    vec = model.encode(text)
    best_cat, best_form, best_sim = None, None, 0
    for cat, data in LIB.libraries.items():
        for f in data["formulas"]:
            if "embedding" in f:
                sim = np.dot(vec, f["embedding"]) / (np.linalg.norm(vec) * np.linalg.norm(f["embedding"]))
                if sim > best_sim:
                    best_cat, best_form, best_sim = cat, f["id"], sim
    return best_cat, best_form, best_sim
âœ… 6. æ–°æ‹†åˆ†æµç¨‹(disassemble_v2.py)
Python
å¤åˆ¶
# plotforge/disassemble_v2.py
from .describe_classifier import classify_paragraph
from .formula_loader import LIB

def disassemble_to_formulas(text: str):
    paragraphs = text.split("\n\n")
    formulas_extracted = []          # åªå­˜å…¬å¼ID
    for p in paragraphs:
        cat, fid, conf = classify_paragraph(p)
        if conf > 0.75:              # é«˜ç½®ä¿¡æ‰æ”¶
            formulas_extracted.append({"cat": cat, "formula_id": fid})
    return formulas_extracted
âœ… 7. æ–°é‡æ„æµç¨‹(reconstruct_from_formula.py)
Python
å¤åˆ¶
# plotforge/reconstruct_from_formula.py
from .formula_loader import LIB

def rebuild_from_formulas(formula_list: list[dict]) -> str:
    novel = []
    for item in formula_list:
        cat = item["cat"]
        fid = item["formula_id"]
        instances = LIB.search_instances(cat, fid, top_k=1)  # å–æœ€ç›¸ä¼¼1æ¡
        novel.append(instances[0]["text"])
    return "\n\n".join(novel)
âœ… 8. å®Œæ•´æ¼”ç¤º(ç™¾ä¸‡å­—â†’å…¬å¼â†’æ–°æ–‡)
Python
å¤åˆ¶
# demo_formula_flow.py
from plotforge.disassemble_v2 import disassemble_to_formulas
from plotforge.reconstruct_from_formula import rebuild_from_formulas

# 1. æ‹†æˆå…¬å¼
with open("data/big_novel.txt", encoding="utf-8") as f:
    big_text = f.read()
formulas = disassemble_to_formulas(big_text)
print(f"å…±æå– {len(formulas)} æ¡å…¬å¼")

# 2. å…¬å¼â†’æ–°æ–‡
new_novel = rebuild_from_formulas(formulas)
with open("data/from_formula_novel.txt", "w", encoding="utf-8") as f:
    f.write(new_novel)

print("âœ… å…¬å¼åº“é‡æ„å®Œæˆ!å‰3æ®µ:")
print("\n\n".join(new_novel.split("\n\n")[:3]))
âœ… 9. ç›®å½•è¡¥å…¨è®¡åˆ’(ä½ å…ˆæŒ‘)
è¡¨æ ¼
å¤åˆ¶
ç±»åˆ«	å­å…¬å¼(æˆ‘å…ˆå¡« 50 æ¡å®ä¾‹)
äººç‰©å¤–è²Œ	æ¸…å†·å¥³ä¸»ã€å¦–åªšå¥³é…ã€é“è¡€ç¡¬æ±‰ã€ä»™æ°”è€è€…â€¦â€¦
ç¯å¢ƒæå†™	æ¸…æ™¨å±±é—¨ã€æœˆå¤œç«¹æµ·ã€é›ªè½å¤åŸã€ç«å±±ç‚¼ç‹±â€¦â€¦
æˆ˜æ–—æå†™	å‰‘æ°”çºµæ¨ªã€åˆ€æ„å¦‚å±±ã€æ³•æœ¯å¯¹è½°ã€è¿‘èº«ææ€â€¦â€¦
å¿ƒç†æå†™	æƒŠå–œã€ç»æœ›ã€æ€æ„ã€æ‚Ÿé“ã€å¿ƒé­”æ»‹ç”Ÿâ€¦â€¦
è½¬åœºè¿‡æ¸¡	æ—¶é—´è·³è·ƒã€ç©ºé—´åˆ‡æ¢ã€å›å¿†æ€ã€é•œå¤´æ‹‰è¿œâ€¦â€¦
âœ… 10. ä¸‹ä¸€æ­¥(ä½ ç‚¹)
"å…ˆå¡« 1000 æ¡å®ä¾‹" â†’ æˆ‘å†™è„šæœ¬æ‰¹é‡ç”Ÿæˆ+äººå·¥æ¶¦è‰²
"äººå·¥å¯¼å…¥<æ–‡å­¦è¾å…¸>" â†’ ç»™ä½  Excelâ†’YAML è½¬æ¢å™¨
"ç»§ç»­åŠ åŠŸèƒ½" â†’ å…¬å¼åµŒå¥—ã€å¤šé£æ ¼èåˆã€å…¬å¼éš¾åº¦ç­‰çº§